    <script>
        // Variables globales
        let currentChatId = null;
        let chats = new Map();
        let currentFilter = 'all';
        let socket = null;
        let isConnected = false;
        let qrModalClosedByConnection = false; // Flag para saber si el modal se cerr√≥ por conexi√≥n exitosa
        let currentUser = null;
        let token = null;
        let selectedFiles = [];
        
        // Cach√© para rastrear chats que ya cargaron sus mensajes viejos
        let loadedChatsCache = new Set();
        let chatMessagesCache = new Map(); // Almacenar mensajes cargados por chat
        
        // Set para rastrear chats que ya mostraron la notificaci√≥n de mensajes cargados
        let notificationShownChats = new Set();

        // InicializaciÔøΩn
        // Funci√≥n para manejar cambios de tama√±o de ventana
        function handleWindowResize() {
            const sidebar = document.getElementById('sidebar');
            const chatArea = document.getElementById('chat-area');
            const toggleBtn = document.getElementById('sidebar-toggle-btn');
            const icon = toggleBtn?.querySelector('i');

            // Limpiar clases m√≥viles cuando se cambia a desktop
            if (window.innerWidth > 480) {
                sidebar?.classList.remove('mobile-open');
                chatArea?.classList.remove('mobile-active');
                removeMobileOverlay();
                
                // Restaurar estado normal en desktop
                if (window.innerWidth > 768) {
                    sidebar?.classList.remove('expanded');
                    toggleBtn?.classList.remove('slide-right');
                    if (icon) {
                        icon.className = 'fas fa-bars';
                        toggleBtn.title = 'Mostrar/Ocultar Panel';
                    }
                }
            }

            // Ajustar scroll de lista de chats para el nuevo tama√±o
            const chatList = document.getElementById('chat-list');
            if (chatList) {
                chatList.style.scrollBehavior = 'smooth';
            }

            // Forzar rec√°lculo de dimensiones de scroll para mensajes
            const messagesArea = document.getElementById('messages-area');
            if (messagesArea && currentChatId) {
                // Peque√±o delay para que se complete el resize
                setTimeout(() => {
                    if (messagesArea.scrollHeight > messagesArea.clientHeight) {
                        messagesArea.scrollTop = messagesArea.scrollHeight;
                    }
                }, 100);
            }

            console.log(`üì± Window resize: ${window.innerWidth}x${window.innerHeight}`);
        }

        document.addEventListener('DOMContentLoaded', function() {
            checkExistingSession();
            setupLoginEvents();
            initMobileScrollObserver();
            
            // Agregar listener para cambios de tama√±o de ventana
            let resizeTimeout;
            window.addEventListener('resize', function() {
                // Debounce para evitar llamadas excesivas
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(handleWindowResize, 250);
            });

            // Agregar listener para cambio de orientaci√≥n en m√≥vil
            window.addEventListener('orientationchange', function() {
                setTimeout(handleWindowResize, 500); // Delay mayor para orientationchange
            });
        });

        function checkExistingSession() {
            const savedToken = localStorage.getItem('token');
            console.log('üîç Checking existing session...');
            console.log('üìã Saved token in localStorage:', savedToken ? 'EXISTS' : 'NULL');
            
            if (savedToken) {
                console.log('‚úÖ Token found, verifying session...');
                verifySession(savedToken);
            } else {
                console.log('‚ùå No token found, showing login screen');
                showLoginScreen();
            }
        }

        function showLoginScreen() {
            const loginContainer = document.getElementById('login-container');
            const mainContainer = document.getElementById('main-container');
            
            if (loginContainer) loginContainer.style.display = 'flex';
            if (mainContainer) mainContainer.style.display = 'none';
        }

        function setupLoginEvents() {
            const loginForm = document.getElementById('login-form');
            if (loginForm) {
                loginForm.addEventListener('submit', handleLogin);
            }

            const logoutBtn = document.getElementById('logout-btn');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', handleLogout);
            }
        }

        async function handleLogin(e) {
            e.preventDefault();

            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value.trim();
            const loginBtn = document.getElementById('login-btn');

            if (!username || !password) {
                showLoginError('Por favor ingresa usuario y contraseÔøΩa');
                return;
            }

            try {
                loginBtn.disabled = true;
                loginBtn.innerHTML = '<div class="loading"></div> Iniciando...';

                console.log('üîê Iniciando proceso de login...');
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });

                console.log('üì° Respuesta del servidor:', response.status);

                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('Credenciales incorrectas');
                    } else if (response.status === 403) {
                        throw new Error('Acceso denegado');
                    } else if (response.status >= 500) {
                        throw new Error('Error del servidor. Intenta m√°s tarde');
                    } else {
                        throw new Error(`Error HTTP ${response.status}`);
                    }
                }

                const data = await response.json();
                console.log('üìã Datos de respuesta:', data);

                if (data.success && data.token) {
                    console.log('=== LOGIN SUCCESSFUL - Starting QR modal sequence ===');
                    currentUser = data.user;
                    token = data.token;
                    localStorage.setItem('token', token);

                    // Validar la sesi√≥n antes de mostrar la app
                    console.log('üîç Validando sesi√≥n despu√©s del login...');
                    const sessionValid = await validateSession();
                    if (!sessionValid) {
                        throw new Error('Sesi√≥n no pudo ser validada despu√©s del login');
                    }

                    // Resetear flag para permitir mostrar el modal QR en esta nueva sesi√≥n
                    qrModalClosedByConnection = false;
                    console.log('QR modal flag reset to:', qrModalClosedByConnection);

                    // Inicializar los botones QR, contador de sesi√≥n y manejo de errores de audio
                    console.log('Initializing QR buttons, session counter and audio error handling...');
                    initializeQRButton();
                    initializeScanQRButton();
                    initializeSessionCounter();
                    setupAudioErrorHandling();
                    fixMultimediaUrls();

                    // Verificar que el modal QR est√© oculto despu√©s del login
                    setTimeout(() => {
                        const qrModal = document.getElementById('qr-modal');
                        if (qrModal && !qrModal.classList.contains('hidden')) {
                            console.error('‚ùå QR modal is visible after login - this should not happen!');
                            console.log('QR modal classes:', qrModal.classList.toString());
                            // Forzar ocultar el modal
                            qrModal.classList.add('hidden');
                            console.log('‚úÖ QR modal forced hidden after login');
                        } else {
                            console.log('‚úÖ QR modal correctly hidden after login');
                        }
                    }, 500);
                    
                    showMainApp();
                    initializeApp();
                    setupEventListeners();
                    startPolling();

                    // Iniciar mantenimiento autom√°tico de sesi√≥n
                    initializeSessionMaintenance();
                } else {
                    showLoginError(data.message || 'Error de autenticaciÔøΩn');
                }
            } catch (error) {
                console.error('‚ùå Error en login:', error);
                showLoginError(error.message || 'Error de conexi√≥n. Intenta nuevamente.');

                // Limpiar datos corruptos si es necesario
                localStorage.removeItem('token');
                token = null;
                currentUser = null;
            } finally {
                loginBtn.disabled = false;
                loginBtn.innerHTML = '<i class="fas fa-sign-in-alt"></i> Iniciar SesiÔøΩn';
            }
        }

        function showLoginError(message) {
            const loginError = document.getElementById('login-error');
            if (loginError) {
                loginError.textContent = message;
                loginError.style.display = 'block';
                setTimeout(() => loginError.style.display = 'none', 5000);
            }
        }

        // Funci√≥n para validar sesi√≥n antes de operaciones cr√≠ticas
        async function validateSession() {
            if (!token) {
                console.error('‚ùå No hay token para validar');
                showNotification('Sesi√≥n no iniciada', 'error');
                showLoginScreen();
                return false;
            }

            try {
                console.log('üîç Validando sesi√≥n activa...');
                const response = await fetch(`/api/session?token=${token}`);
                const data = await response.json();

                if (data.success && data.user) {
                    console.log('‚úÖ Sesi√≥n v√°lida:', data.user.username);
                    currentUser = data.user;
                    return true;
                } else {
                    console.error('‚ùå Sesi√≥n inv√°lida o expirada');
                    showNotification('Sesi√≥n expirada. Redirigiendo al login...', 'error');
                    localStorage.removeItem('token');
                    token = null;
                    showLoginScreen();
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error validando sesi√≥n:', error);
                showNotification('Error de conexi√≥n. Verificando sesi√≥n...', 'error');
                // Intentar reconectar en 3 segundos
                setTimeout(() => {
                    if (token) validateSession();
                }, 3000);
                return false;
            }
        }

        async function verifySession(savedToken) {
            try {
                console.log('üîê Verificando sesi√≥n en inicializaci√≥n...');
                console.log('üé´ Token to verify:', savedToken.substring(0, 20) + '...');
                const response = await fetch(`/api/session?token=${savedToken}`);
                console.log('üì° Response status:', response.status);
                const data = await response.json();
                console.log('üìã Response data:', data);

                if (data.success) {
                    currentUser = data.user;
                    // Asignar el token a la variable global
                    token = savedToken;
                    window.token = savedToken;
                    console.log('‚úÖ Sesi√≥n verificada exitosamente:', data.user.username);
                    console.log('üé´ Token assigned to global scope:', savedToken.substring(0, 20) + '...');

                    // Validar sesi√≥n completa antes de mostrar la app
                    const isValid = await validateSession();
                    if (isValid) {
                        showMainApp();
                        initializeApp();
                        setupEventListeners();
                        startPolling();
                        // Iniciar mantenimiento autom√°tico de sesi√≥n
                        initializeSessionMaintenance();
                    }
                } else {
                    console.error('‚ùå Verificaci√≥n de sesi√≥n fallida');
                    console.error('üìã Failed response data:', data);
                    localStorage.removeItem('token');
                    showLoginScreen();
                }
            } catch (error) {
                console.error('‚ùå Error verificando sesi√≥n:', error);
                console.error('üìã Error details:', error.message);
                localStorage.removeItem('token');
                showLoginScreen();
            }
        }

        function showMainApp() {
            const loginContainer = document.getElementById('login-container');
            const mainContainer = document.getElementById('main-container');

            if (loginContainer) loginContainer.style.display = 'none';
            if (mainContainer) mainContainer.style.display = 'flex';

            updateUserInfo();
        }

        function updateUserInfo() {
            // La informaci√≥n del usuario ahora se muestra a trav√©s del bot√≥n de "Gesti√≥n de Visitas"
            // que solo aparece para usuarios administradores

            if (currentUser) {
                console.log('üë§ User info updated:', currentUser.nombre, `(${currentUser.rol})`);

                // Mostrar bot√≥n de gesti√≥n de visitas para todos los usuarios
                const adminVisitsBtn = document.getElementById('admin-visits-btn');
                if (adminVisitsBtn) {
                    adminVisitsBtn.style.display = 'flex';
                }
            }
        }

        async function handleLogout() {
            try {
                if (token) {
                    await fetch('/api/logout', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token })
                    });
                }
            } catch (error) {
                console.error('Error en logout:', error);
            } finally {
                currentUser = null;
                token = null;
                localStorage.removeItem('token');
                
                // Limpiar cach√© de mensajes y notificaciones al cerrar sesi√≥n
                loadedChatsCache.clear();
                chatMessagesCache.clear();
                notificationShownChats.clear();
                console.log('üíæ Cach√© de mensajes y notificaciones limpiado al cerrar sesi√≥n');

                const loginContainer = document.getElementById('login-container');
                const mainContainer = document.getElementById('main-container');

                if (loginContainer) loginContainer.style.display = 'flex';
                if (mainContainer) mainContainer.style.display = 'none';

                document.getElementById('username').value = '';
                document.getElementById('password').value = '';

                showNotification('SesiÔøΩn cerrada correctamente', 'info');
            }
        }

        function initializeApp() {
            // NO ocultar el modal QR aqu√≠ - debe mantenerse visible hasta que WhatsApp se conecte
            // El modal QR se muestra en handleLogin() antes de inicializar la app

            // Inicializar manejo de errores de audio y corregir URLs multimedia
            setupAudioErrorHandling();
            fixMultimediaUrls();

            // Verificar conexi√≥n despu√©s de un peque√±o delay
            setTimeout(() => {
                checkConnectionStatus();
            }, 1000);
            loadChats();
        }

        function setupEventListeners() {
            if (window.eventListenersSetup) return;
            window.eventListenersSetup = true;

            // Filtros de chat
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentFilter = this.dataset.filter;
                    filterChats();
                });
            });

            // Manejo de archivos
            setupFileHandling();

            // EnvÔøΩo de mensajes
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');

            if (messageInput) {
            messageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            messageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 100) + 'px';
            });
            }

            if (sendBtn) {
                sendBtn.addEventListener('click', sendMessage);
            }

            // Configurar grabaci√≥n de audio
            setupAudioRecording();

            // Botones de acciÔøΩn
            const refreshMessagesBtn = document.getElementById('refresh-messages-btn');
            const toggleModeBtn = document.getElementById('toggle-mode-btn');
            const endChatBtn = document.getElementById('end-chat-btn');
            const adminVisitsBtn = document.getElementById('admin-visits-btn');
            const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');

            if (refreshMessagesBtn) refreshMessagesBtn.addEventListener('click', () => {
                if (currentChatId) {
                    loadMessagesSmart(currentChatId, true, false); // Forzar recarga completa, no silencioso
                    showNotification('Refrescando mensajes...', 'info');
                }
            });
            if (toggleModeBtn) toggleModeBtn.addEventListener('click', toggleChatMode);
            if (endChatBtn) endChatBtn.addEventListener('click', endChat);
            if (adminVisitsBtn) adminVisitsBtn.addEventListener('click', openAdminPanel);
            if (sidebarToggleBtn) sidebarToggleBtn.addEventListener('click', toggleSidebar);
        }

        // FunciÔøΩn para toggle del sidebar
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebar-toggle-btn');
            const icon = toggleBtn.querySelector('i');
            const chatArea = document.getElementById('chat-area');

            // Manejo mejorado para dispositivos m√≥viles
            if (window.innerWidth <= 480) {
                // En m√≥vil: alternar clases mobile-open/mobile-hidden
                sidebar.classList.toggle('mobile-open');
                
                if (sidebar.classList.contains('mobile-open')) {
                    icon.className = 'fas fa-arrow-left';
                    toggleBtn.title = 'Ocultar Panel';
                    // Ocultar √°rea de chat cuando se muestra sidebar en m√≥vil
                    if (chatArea) {
                        chatArea.classList.remove('mobile-active');
                    }
                    // Agregar overlay para cerrar sidebar tocando fuera
                    addMobileOverlay();
                } else {
                    icon.className = 'fas fa-bars';
                    toggleBtn.title = 'Mostrar Panel';
                    removeMobileOverlay();
                }
            } else if (window.innerWidth <= 768) {
                // En tablet: usar l√≥gica existente
                sidebar.classList.toggle('expanded');

                if (sidebar.classList.contains('expanded')) {
                    toggleBtn.classList.add('slide-right');
                    icon.className = 'fas fa-arrow-left';
                    toggleBtn.title = 'Ocultar Panel';

                    if (chatArea && chatArea.classList.contains('fullscreen')) {
                        chatArea.classList.remove('fullscreen');
                    }
                } else {
                    toggleBtn.classList.remove('slide-right');
                    icon.className = 'fas fa-bars';
                    toggleBtn.title = 'Mostrar Panel';
                }
            } else {
                // En desktop: l√≥gica original
                sidebar.classList.toggle('hidden');

                if (sidebar.classList.contains('hidden')) {
                    icon.className = 'fas fa-arrow-right';
                    toggleBtn.title = 'Mostrar Panel';
                } else {
                    icon.className = 'fas fa-bars';
                    toggleBtn.title = 'Ocultar Panel';
                }
            }
        }

        // ===== FUNCIONALIDAD DE GRABACI√ìN DE AUDIO =====
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;

        function setupAudioRecording() {
            const audioBtn = document.getElementById('audio-btn');
            if (!audioBtn) return;

            audioBtn.addEventListener('click', toggleAudioRecording);
        }

        async function toggleAudioRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        async function startRecording() {
            try {
                console.log('üé§ Iniciando grabaci√≥n de audio...');
                
                // Solicitar permisos de micr√≥fono
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    } 
                });

                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    handleRecordingComplete();
                    // Detener el stream
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();

                // Actualizar UI
                const audioBtn = document.getElementById('audio-btn');
                audioBtn.classList.add('recording');
                audioBtn.innerHTML = '<i class="fas fa-stop"></i>';
                audioBtn.title = 'Detener grabaci√≥n';

                showNotification('üé§ Grabando audio... Click para detener', 'info');

            } catch (error) {
                console.error('Error iniciando grabaci√≥n:', error);
                showNotification('‚ùå Error accediendo al micr√≥fono. Verifica permisos.', 'error');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                console.log('‚èπÔ∏è Deteniendo grabaci√≥n...');
                mediaRecorder.stop();
                isRecording = false;

                // Actualizar UI
                const audioBtn = document.getElementById('audio-btn');
                audioBtn.classList.remove('recording');
                audioBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                audioBtn.title = 'Grabar audio';
            }
        }

        async function handleRecordingComplete() {
            try {
                const recordingDuration = Date.now() - recordingStartTime;
                console.log(`üéµ Grabaci√≥n completada. Duraci√≥n: ${recordingDuration}ms`);

                if (recordingDuration < 1000) {
                    showNotification('‚ö†Ô∏è La grabaci√≥n debe durar al menos 1 segundo', 'warning');
                    return;
                }

                // Crear blob de audio
                const audioBlob = new Blob(audioChunks, { 
                    type: 'audio/webm;codecs=opus' 
                });

                console.log('üìÅ Audio blob creado:', {
                    size: audioBlob.size,
                    type: audioBlob.type
                });

                // Mostrar vista previa del audio antes de enviar
                showAudioPreview(audioBlob);

            } catch (error) {
                console.error('Error procesando audio:', error);
                showNotification('‚ùå Error procesando el audio grabado', 'error');
            }
        }

        function showAudioPreview(audioBlob) {
            console.log('üîä Mostrando vista previa de audio');
            
            // Crear URL del blob para reproducci√≥n
            const audioUrl = URL.createObjectURL(audioBlob);
            const duration = Math.round((Date.now() - recordingStartTime) / 1000);
            
            // Crear elemento de vista previa
            const previewContainer = document.createElement('div');
            previewContainer.className = 'audio-preview-container';
            previewContainer.innerHTML = `
                <div class="audio-preview-header">
                    <i class="fas fa-microphone"></i>
                    <span>Audio grabado (${duration}s)</span>
                    <button class="audio-preview-close" onclick="cancelAudioPreview()">&times;</button>
                </div>
                <div class="audio-preview-content">
                    <audio controls class="audio-preview-player">
                        <source src="${audioUrl}" type="audio/webm">
                        Tu navegador no soporta la reproducci√≥n de audio.
                    </audio>
                    <div class="audio-preview-actions">
                        <button class="audio-preview-btn cancel" onclick="cancelAudioPreview()">
                            <i class="fas fa-trash"></i> Descartar
                        </button>
                        <button class="audio-preview-btn send" onclick="confirmSendAudio()">
                            <i class="fas fa-paper-plane"></i> Enviar
                        </button>
                    </div>
                </div>
            `;
            
            // Agregar estilos
            const style = document.createElement('style');
            style.textContent = `
                .audio-preview-container {
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: white;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    z-index: 10000;
                    min-width: 350px;
                    max-width: 400px;
                    width: 90%;
                    max-height: 90vh;
                    overflow: hidden;
                }
                
                
                .audio-preview-header {
                    background: #0084ff;
                    color: white;
                    padding: 12px 16px;
                    border-radius: 12px 12px 0 0;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-weight: 500;
                }
                
                .audio-preview-close {
                    margin-left: auto;
                    background: none;
                    border: none;
                    color: white;
                    font-size: 20px;
                    cursor: pointer;
                    padding: 0;
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                
                .audio-preview-close:hover {
                    background: rgba(255,255,255,0.2);
                }
                
                .audio-preview-content {
                    padding: 20px;
                }
                
                .audio-preview-player {
                    width: 100%;
                    margin-bottom: 16px;
                    border-radius: 6px;
                }
                
                .audio-preview-actions {
                    display: flex;
                    gap: 12px;
                    justify-content: center;
                }
                
                .audio-preview-btn {
                    padding: 10px 20px;
                    border: none;
                    border-radius: 6px;
                    font-weight: 500;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    transition: all 0.2s ease;
                }
                
                .audio-preview-btn.cancel {
                    background: #f44336;
                    color: white;
                }
                
                .audio-preview-btn.cancel:hover {
                    background: #d32f2f;
                }
                
                .audio-preview-btn.send {
                    background: #4caf50;
                    color: white;
                }
                
                .audio-preview-btn.send:hover {
                    background: #388e3c;
                }
                
                .audio-preview-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    z-index: 9999;
                }
            `;
            
            // Crear overlay de fondo
            const overlay = document.createElement('div');
            overlay.className = 'audio-preview-overlay';
            overlay.onclick = () => cancelAudioPreview();
            
            // Agregar elementos al DOM
            document.head.appendChild(style);
            document.body.appendChild(overlay);
            document.body.appendChild(previewContainer);
            
            // Guardar referencias globales
            window.currentAudioBlob = audioBlob;
            window.currentAudioUrl = audioUrl;
            window.currentPreviewContainer = previewContainer;
            window.currentPreviewOverlay = overlay;
            window.currentPreviewStyle = style;
            
            // Agregar listener para cerrar con Escape
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    cancelAudioPreview();
                }
            };
            document.addEventListener('keydown', escapeHandler);
            window.currentEscapeHandler = escapeHandler;
            
            // Focus en el primer bot√≥n y configurar eventos de audio
            setTimeout(() => {
                const firstBtn = previewContainer.querySelector('.audio-preview-btn');
                if (firstBtn) firstBtn.focus();
                
                // Configurar eventos del reproductor de audio
                const audioPlayer = previewContainer.querySelector('.audio-preview-player');
                if (audioPlayer) {
                    audioPlayer.addEventListener('play', () => {
                        console.log('‚ñ∂Ô∏è Reproduciendo audio grabado');
                    });
                    
                    audioPlayer.addEventListener('pause', () => {
                        console.log('‚è∏Ô∏è Audio pausado');
                    });
                    
                    audioPlayer.addEventListener('ended', () => {
                        console.log('‚èπÔ∏è Reproducci√≥n terminada');
                    });
                }
            }, 100);
        }

        function cancelAudioPreview() {
            console.log('‚ùå Cancelando vista previa de audio');
            
            // Limpiar URL del blob
            if (window.currentAudioUrl) {
                URL.revokeObjectURL(window.currentAudioUrl);
            }
            
            // Remover elementos del DOM
            if (window.currentPreviewContainer) {
                window.currentPreviewContainer.remove();
            }
            if (window.currentPreviewOverlay) {
                window.currentPreviewOverlay.remove();
            }
            if (window.currentPreviewStyle) {
                window.currentPreviewStyle.remove();
            }
            
            // Remover listener del teclado
            if (window.currentEscapeHandler) {
                document.removeEventListener('keydown', window.currentEscapeHandler);
            }
            
            // Limpiar referencias
            window.currentAudioBlob = null;
            window.currentAudioUrl = null;
            window.currentPreviewContainer = null;
            window.currentPreviewOverlay = null;
            window.currentPreviewStyle = null;
            window.currentEscapeHandler = null;
            
            showNotification('üóëÔ∏è Audio descartado', 'info');
        }

        function confirmSendAudio() {
            console.log('‚úÖ Confirmando env√≠o de audio');
            
            const audioBlob = window.currentAudioBlob;
            
            // Limpiar vista previa
            cancelAudioPreview();
            
            // Enviar audio
            if (audioBlob) {
                sendAudioMessage(audioBlob);
            }
        }

        async function sendAudioMessage(audioBlob) {
            if (!currentChatId) {
                showNotification('‚ùå No hay chat seleccionado', 'error');
                return;
            }

            try {
                console.log('üì§ Enviando audio a:', currentChatId);

                // Crear FormData con el audio
                const formData = new FormData();
                const audioFile = new File([audioBlob], `audio_${Date.now()}.webm`, {
                    type: 'audio/webm;codecs=opus'
                });
                
                formData.append('audio', audioFile);
                formData.append('chatId', currentChatId);

                // Crear AbortController para timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    console.warn('‚è∞ Env√≠o de audio cancelado por timeout (60 segundos)');
                }, 60000);

                showNotification('üì§ Enviando audio...', 'info');

                const response = await fetch('/api/send-audio', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData,
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Audio enviado exitosamente:', data);
                    showNotification('‚úÖ Audio enviado correctamente', 'success');
                    
                    // Recargar mensajes despu√©s de un momento
                    setTimeout(() => {
                        if (currentChatId) {
                            loadMessagesSmart(currentChatId);
                        }
                    }, 1000);

                } else {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('‚ùå Error enviando audio:', response.status, errorData);
                    showNotification(`‚ùå Error enviando audio: ${errorData.message || response.status}`, 'error');
                }

            } catch (error) {
                console.error('Error enviando audio:', error);
                
                let errorMessage = '‚ùå Error enviando audio';
                if (error.name === 'AbortError') {
                    errorMessage = '‚è∞ Timeout enviando audio - el archivo era demasiado grande o la conexi√≥n lenta';
                } else if (error.message) {
                    errorMessage = `‚ùå Error: ${error.message}`;
                }
                
                showNotification(errorMessage, 'error');
            }
        }

        // Funci√≥n para mostrar notificaci√≥n de historial cargado
        function showHistoryLoadedNotification(messageCount) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 70px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 212, 170, 0.95);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 0.9em;
                font-weight: 500;
                z-index: 9999;
                opacity: 0;
                transition: opacity 0.3s ease;
                backdrop-filter: blur(10px);
                box-shadow: 0 4px 15px rgba(0, 212, 170, 0.3);
                pointer-events: none;
            `;
            notification.innerHTML = `üìö ${messageCount} mensajes del historial cargados`;
            document.body.appendChild(notification);
            
            // Fade in
            setTimeout(() => notification.style.opacity = '1', 50);
            
            // Fade out y remover
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 3000); // Mostrar por m√°s tiempo
        }

        // Funci√≥n para mostrar indicador de carga de historial
        function showHistoryLoadingIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'history-loading-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 70px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(23, 162, 184, 0.95);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 0.9em;
                font-weight: 500;
                z-index: 9999;
                opacity: 0;
                transition: opacity 0.3s ease;
                backdrop-filter: blur(10px);
                box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3);
                pointer-events: none;
            `;
            indicator.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Cargando historial de WhatsApp...`;
            document.body.appendChild(indicator);
            
            // Fade in
            setTimeout(() => indicator.style.opacity = '1', 50);
            
            return indicator;
        }

        // Funci√≥n para ocultar indicador de carga de historial
        function hideHistoryLoadingIndicator() {
            const indicator = document.getElementById('history-loading-indicator');
            if (indicator) {
                indicator.style.opacity = '0';
                setTimeout(() => indicator.remove(), 300);
            }
        }

        // Funci√≥n para mostrar indicador de carga lazy en el √°rea de mensajes
        function showLazyLoadingIndicator() {
            const messagesArea = document.getElementById('messages-area');
            if (!messagesArea) return;

            // Limpiar mensajes existentes
            messagesArea.innerHTML = '';
            
            // Crear indicador de carga lazy
            const loadingIndicator = document.createElement('div');
            loadingIndicator.id = 'lazy-loading-indicator';
            loadingIndicator.style.cssText = `
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 100%;
                color: #8b949e;
                font-size: 0.9em;
                text-align: center;
                animation: fadeIn 0.3s ease;
            `;
            
            loadingIndicator.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <i class="fas fa-comment-dots" style="font-size: 2.5em; color: var(--primary-color); animation: pulse 1.5s ease-in-out infinite;"></i>
                </div>
                <div style="font-weight: 500; margin-bottom: 5px;">Cargando mensajes...</div>
                <div style="font-size: 0.8em; color: #adb5bd;">Obteniendo historial del chat</div>
                
                <style>
                    @keyframes pulse {
                        0% { opacity: 0.6; transform: scale(1); }
                        50% { opacity: 1; transform: scale(1.05); }
                        100% { opacity: 0.6; transform: scale(1); }
                    }
                    
                    @keyframes fadeIn {
                        from { opacity: 0; transform: translateY(20px); }
                        to { opacity: 1; transform: translateY(0); }
                    }
                </style>
            `;
            
            messagesArea.appendChild(loadingIndicator);
        }

        // Funci√≥n para ocultar indicador de carga lazy
        function hideLazyLoadingIndicator() {
            const indicator = document.getElementById('lazy-loading-indicator');
            if (indicator) {
                indicator.style.opacity = '0';
                indicator.style.transform = 'translateY(-20px)';
                setTimeout(() => indicator.remove(), 300);
            }
        }

        // Funci√≥n para limpiar cach√© de un chat espec√≠fico
        function clearChatCache(chatId) {
            let cleared = false;
            if (loadedChatsCache.has(chatId)) {
                loadedChatsCache.delete(chatId);
                chatMessagesCache.delete(chatId);
                cleared = true;
            }
            if (notificationShownChats.has(chatId)) {
                notificationShownChats.delete(chatId);
                cleared = true;
            }
            if (cleared) {
                console.log(`üíæ Cach√© y notificaciones limpiados para chat ${chatId}`);
            }
            return cleared;
        }

        // Funci√≥n para verificar estado del cach√©
        function getCacheStats() {
            return {
                totalCachedChats: loadedChatsCache.size,
                totalCachedMessages: Array.from(chatMessagesCache.values()).reduce((total, messages) => total + messages.length, 0),
                cachedChatIds: Array.from(loadedChatsCache),
                totalNotificationsShown: notificationShownChats.size,
                notificationShownIds: Array.from(notificationShownChats)
            };
        }

        // Funci√≥n para mostrar notificaci√≥n de chats y mensajes cargados - DESHABILITADA
        /*
        function showChatMessagesLoadedNotification(totalChats, totalMessages, source) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: rgba(40, 167, 69, 0.95);
                color: white;
                padding: 10px 16px;
                border-radius: 15px;
                font-size: 0.85em;
                font-weight: 500;
                z-index: 9999;
                opacity: 0;
                transition: opacity 0.3s ease;
                backdrop-filter: blur(10px);
                box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
                pointer-events: none;
                max-width: 280px;
            `;
            
            const sourceText = source === 'whatsapp+cache' ? 'WhatsApp + Cache' : 
                             source === 'whatsapp' ? 'WhatsApp' : 
                             source === 'cache' ? 'Cache Local' : 'Servidor';
                             
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <i class="fas fa-comments" style="font-size: 1.1em;"></i>
                    <div>
                        <div><strong>${totalChats}</strong> chats cargados</div>
                        <div style="opacity: 0.9; font-size: 0.9em;"><strong>${totalMessages}</strong> mensajes desde ${sourceText}</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Fade in
            setTimeout(() => notification.style.opacity = '1', 50);
            
            // Fade out y remover
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 4000); // Mostrar por 4 segundos
        }
        */

        // Funciones auxiliares para manejo m√≥vil
        function addMobileOverlay() {
            if (document.getElementById('mobile-sidebar-overlay')) return;
            
            const overlay = document.createElement('div');
            overlay.id = 'mobile-sidebar-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 999;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            
            document.body.appendChild(overlay);
            
            // Fade in
            setTimeout(() => overlay.style.opacity = '1', 10);
            
            // Cerrar sidebar al hacer click en overlay
            overlay.addEventListener('click', () => {
                const sidebar = document.getElementById('sidebar');
                if (sidebar) sidebar.classList.remove('mobile-open');
                removeMobileOverlay();
                const toggleBtn = document.getElementById('sidebar-toggle-btn');
                if (toggleBtn) {
                    toggleBtn.querySelector('i').className = 'fas fa-bars';
                    toggleBtn.title = 'Mostrar Panel';
                }
            });
        }

        function removeMobileOverlay() {
            const overlay = document.getElementById('mobile-sidebar-overlay');
            if (overlay) {
                overlay.style.opacity = '0';
                setTimeout(() => overlay.remove(), 300);
            }
        }

        function showSidebarFromChat() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebar-toggle-btn');
            const icon = toggleBtn.querySelector('i');
            const chatArea = document.getElementById('chat-area');

            if (window.innerWidth <= 480) {
                // En m√≥vil: ocultar chat y mostrar sidebar
                chatArea.classList.remove('mobile-active');
                sidebar.classList.add('mobile-open');
                icon.className = 'fas fa-arrow-left';
                toggleBtn.title = 'Ocultar Panel';
                addMobileOverlay();
                
                // *** SOLUCION: Reposicionar lista de chats ***
                setTimeout(() => {
                    const chatList = document.getElementById('chat-list');
                    if (chatList && currentChatId) {
                        const activeChatElement = chatList.querySelector('.chat-item.active');
                        if (activeChatElement) {
                            activeChatElement.scrollIntoView({
                                behavior: 'smooth',
                                block: 'center',
                                inline: 'nearest'
                            });
                        }
                    }
                }, 300); // Esperar a que termine la animaci√≥n del sidebar
            } else {
                // L√≥gica original para tablet y desktop
                sidebar.classList.remove('hidden');
                sidebar.classList.add('expanded');

                toggleBtn.classList.add('slide-right');
                icon.className = 'fas fa-arrow-left';
                toggleBtn.title = 'Ocultar Panel';

                if (chatArea && chatArea.classList.contains('fullscreen')) {
                    chatArea.classList.remove('fullscreen');
                }
            }
        }

        function openAdminPanel() {
            console.log('üîó [MAIN] Opening Admin Panel...');

            // Abrir directamente el panel de gesti√≥n de visitas t√©cnicas
            console.log('‚úÖ [MAIN] Opening admin visits panel...');
            window.open('https://192.168.99.122:3000/admin', '_blank');
        }

        // Funci√≥n de debugging para diagnosticar problemas de sesi√≥n
        function debugSession() {
            console.log('üîç === SESSION DEBUG INFO ===');
            console.log('Current page:', window.location.href);
            console.log('Token (variable):', token ? 'SET' : 'NULL');
            console.log('Token (localStorage):', localStorage.getItem('token') ? 'EXISTS' : 'NULL');
            console.log('Current user:', currentUser);
            console.log('User role:', currentUser ? currentUser.rol : 'NULL');
            console.log('================================');

            if (token && localStorage.getItem('token')) {
                console.log('‚úÖ Session appears valid');
                console.log('üí° You can manually navigate to /admin.html');
            } else {
                console.log('‚ùå Session issue detected');
                console.log('üí° Try logging in again');
            }

            return {
                token: token ? 'SET' : 'NULL',
                localStorage: localStorage.getItem('token') ? 'EXISTS' : 'NULL',
                currentUser,
                userRole: currentUser ? currentUser.rol : 'NULL'
            };
        }

        function showUserInfo_OLD() {
            const userName = document.getElementById('user-name').textContent;
            const userRole = document.getElementById('user-role').textContent;

            const modalHTML = `
                <div class="modal-overlay">
                    <div style="background: white; border-radius: 20px; width: 90%; max-width: 400px; overflow: hidden; animation: modalSlideIn 0.3s ease;">
                        <div style="background: linear-gradient(135deg, #17a2b8, #00d4aa); color: white; padding: 20px; display: flex; align-items: center; justify-content: space-between;">
                            <h3 style="margin: 0; font-size: 1.2em; display: flex; align-items: center; gap: 10px;">
                                <i class="fas fa-user"></i> InformaciÔøΩn del Usuario
                            </h3>
                            <button onclick="closeUserInfoModal()" style="background: rgba(255, 255, 255, 0.2); border: none; color: white; padding: 8px; border-radius: 6px; cursor: pointer;">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div style="padding: 30px; text-align: center;">
                            <div style="font-size: 4em; color: #17a2b8; margin-bottom: 20px;">
                                <i class="fas fa-user-circle"></i>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #e9ecef;">
                                    <label style="font-weight: 600; color: #495057; font-size: 0.9em;">Nombre:</label>
                                    <span style="font-weight: 500; color: #212529;">${userName}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #e9ecef;">
                                    <label style="font-weight: 600; color: #495057; font-size: 0.9em;">Rol:</label>
                                    <span style="background: linear-gradient(135deg, #00d4aa, #17a2b8); color: white; padding: 4px 12px; border-radius: 15px; font-size: 0.8em; font-weight: 600;">${userRole}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
                                    <label style="font-weight: 600; color: #495057; font-size: 0.9em;">Estado:</label>
                                    <span style="display: flex; align-items: center; gap: 5px; color: #28a745; font-weight: 600; font-size: 0.9em;">
                                        <i class="fas fa-circle" style="font-size: 0.7em;"></i> Conectado
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        function closeUserInfoModal() {
            const modal = document.querySelector('.modal-overlay');
            if (modal) modal.remove();
        }

        // Cerrar modal al hacer clic fuera
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('modal-overlay')) {
                closeUserInfoModal();
            }
        });

        // Cerrar modal con tecla Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeUserInfoModal();
                closeOmittedModal();
                closeUsersAdminModal();
                closeLogsAPIModal();
                closeNewChatModal();
                closeEditUserModal();
                closeAddUserModal();
            }
        });

        async function checkConnectionStatus() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();

                console.log('Connection status response:', data); // Debug log
                
                const statusIndicator = document.getElementById('connection-status');
                const statusText = document.getElementById('status-text');
                
                // Verificar m√∫ltiples indicadores de conexi√≥n
                const isWhatsAppReady = data.whatsappListo || data.connected || data.ready;
                console.log('WhatsApp ready status:', isWhatsAppReady); // Debug log

                if (isWhatsAppReady) {
                    statusIndicator.className = 'status-indicator status-online';
                    statusText.textContent = 'WhatsApp Conectado';
                    
                    // Detectar reconexi√≥n (si antes estaba desconectado)
                    const wasDisconnected = !isConnected;
                    isConnected = true;
                    console.log('üöÄ [CONNECTION] isConnected establecido a TRUE');

                    // Si hubo reconexi√≥n, recuperar mensajes autom√°ticamente
                    if (wasDisconnected) {
                        console.log('üîÑ [RECOVERY] WhatsApp reconectado - iniciando recuperaci√≥n autom√°tica...');
                        setTimeout(() => {
                            recoverMessagesAfterReconnection();
                        }, 2000); // Esperar 2 segundos para que la conexi√≥n se estabilice
                    }

                    // Marcar que WhatsApp est√° conectado para futuras referencias
                    qrModalClosedByConnection = true;

                    // Actualizar visibilidad de los botones QR (ocultarlos)
                    updateQRButtonVisibility();
                    updateScanQRButtonVisibility();

                    // Verificar si el modal QR est√° visible
                    const qrModal = document.getElementById('qr-modal');
                    const isModalVisible = qrModal && !qrModal.classList.contains('hidden');

                    if (isModalVisible) {
                        // Actualizar indicador de estado
                        updateQRStatusIndicator('connected', '<i class="fas fa-check-circle"></i> ¬°WhatsApp conectado! La ventana se cerrar√° autom√°ticamente...');

                        // Mostrar notificaci√≥n de conexi√≥n exitosa
                        showNotification('¬°WhatsApp conectado exitosamente!', 'success');

                        // Cerrar el modal despu√©s de 2 segundos para dar tiempo a que el usuario vea la confirmaci√≥n
                        setTimeout(() => {
                            hideQRModalByConnection();
                        }, 2000);
                    } else {
                        console.log('WhatsApp connected - QR modal was not visible');
                        // Asegurar que el modal est√© cerrado por si acaso
                        hideQRModalByConnection();
                    }

                    console.log('WhatsApp connected - hiding QR modal');
                    console.log('Connection data:', {
                        whatsappListo: data.whatsappListo,
                        connected: data.connected,
                        ready: data.ready,
                        hasSession: data.hasSession,
                        sessionActive: data.sessionActive
                    });
                } else {
                    statusIndicator.className = 'status-indicator status-offline';
                    statusText.textContent = 'WhatsApp Desconectado';
                    isConnected = false;

                    // Actualizar visibilidad de los botones QR
                    updateQRButtonVisibility();
                    updateScanQRButtonVisibility();

                    console.log('WhatsApp disconnected - connection data:', {
                        whatsappListo: data.whatsappListo,
                        connected: data.connected,
                        ready: data.ready,
                        hasSession: data.hasSession,
                        sessionActive: data.sessionActive
                    });

                    // No mostrar autom√°ticamente el modal QR - solo mostrar el bot√≥n
                    console.log('QR button available for manual QR display');
                }
            } catch (error) {
                console.error('Error checking connection:', error);
                const statusIndicator = document.getElementById('connection-status');
                const statusText = document.getElementById('status-text');
                statusIndicator.className = 'status-indicator status-offline';
                statusText.textContent = 'Error de Conexi√≥n';

                // Verificar si el modal QR ya est√° visible
                const qrModal = document.getElementById('qr-modal');
                const isModalVisible = qrModal && !qrModal.classList.contains('hidden');

                if (!isModalVisible) {
                    // Actualizar indicador de estado a error y mostrar modal
                    updateQRStatusIndicator('error', '<i class="fas fa-exclamation-triangle"></i> Error de conexi√≥n - Reintentando...');
                    showQRModal();
                } else {
                    // Solo actualizar el indicador si el modal ya est√° visible
                    updateQRStatusIndicator('error', '<i class="fas fa-exclamation-triangle"></i> Error de conexi√≥n - Reintentando...');
                }
            }
        }

        let lastChatsCount = 0;
        let lastMessagesCount = 0;
        let chatCache = new Map(); // Cache para evitar cargar chats repetidamente
        let lastChatHash = null;   // Hash para detectar cambios reales

        async function loadChats() {
            try {
                console.log('üìû [LOAD-CHATS] Iniciando petici√≥n a /api/all-chats...');
                const response = await fetch('/api/all-chats');
                console.log('üìû [LOAD-CHATS] Respuesta recibida:', response.status, response.ok);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('üìû [LOAD-CHATS] Datos recibidos:', data);
                    
                    // Crear hash de los datos para detectar cambios reales
                    const currentHash = JSON.stringify(data.chats || []).substring(0, 100);
                    console.log('üìû [LOAD-CHATS] Hash actual:', currentHash, 'Hash anterior:', lastChatHash);
                    
                    // Siempre actualizar para asegurar que se muestren los chats
                    if (true) {
                        console.log('üìû [LOAD-CHATS] Actualizando lista de chats (forzado)...');
                        const currentChatsCount = data.totalChats || 0;
                        const currentMessagesCount = data.totalMessages || 0;
                        
                        if (currentChatsCount !== lastChatsCount || currentMessagesCount !== lastMessagesCount) {
                            console.log('üîÑ [LOAD CHATS] Detectados cambios - actualizando...');
                            console.log(`üìã [CHATS LOADED] ${currentChatsCount} chats cargados`);
                            console.log(`üìä [MESSAGES TOTAL] ${currentMessagesCount} mensajes totales obtenidos`);
                            console.log(`üì° [SOURCE] Datos desde: ${data.source || 'unknown'}`);
                            
                            // Log de estad√≠sticas por chat solo si hay chats nuevos o modificados
                            if (data.chats && data.chats.length > 0) {
                                data.chats.forEach(chat => {
                                    if (chat.messagesCount > 0 && !chatCache.has(chat.id)) {
                                        console.log(`   üí¨ ${chat.name}: ${chat.messagesCount} mensajes, √∫ltimo: ${new Date(chat.lastActivity).toLocaleString()}`);
                                    }
                                });
                            }
                            
                            lastChatsCount = currentChatsCount;
                            lastMessagesCount = currentMessagesCount;
                        }
                        
                        lastChatHash = currentHash;
                        updateChatList(data.chats || []);
                    } else {
                        console.log('üìû [LOAD-CHATS] Sin cambios detectados, omitiendo actualizaci√≥n');
                    }
                } else {
                    console.error('üìû [LOAD-CHATS] Error HTTP:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('üìû [LOAD-CHATS] Error en petici√≥n:', error);
            }
        }

        function updateChatList(chatData) {
            const chatList = document.getElementById('chat-list');
            let hasChanges = false;
            
            console.log('üìù [UPDATE-CHAT-LIST] Procesando', chatData.length, 'chats');
            
            chatData.forEach(chat => {
                console.log('üìù [CHAT-DATA]', chat.name, '- √öltimo mensaje:', chat.lastMessage);
                
                // FORZAR ACTUALIZACI√ìN: Siempre actualizar para solucionar el problema
                console.log('üìù [CHAT-UPDATE] Actualizando chat:', chat.name, '√öltimo mensaje:', chat.lastMessage);
                chats.set(chat.id, chat);
                chatCache.set(chat.id, chat); // Marcar como cargado
                hasChanges = true;
            });

            // Solo re-renderizar si hay cambios reales
            if (hasChanges) {
                renderChatList();
            } else if (chatData.length > 0 && Array.from(chats.values()).length === 0) {
                // Forzar renderizado si hay datos pero no hay chats renderizados
                console.log('üîß [FORCE-RENDER] Forzando renderizado porque hay datos pero no chats visibles');
                renderChatList();
            }
        }

        function renderChatList() {
            const chatList = document.getElementById('chat-list');

            console.log('üé® [RENDER-CHAT-LIST] Iniciando renderizado, chats disponibles:', chats.size);

            const filteredChats = Array.from(chats.values()).filter(chat => {
                if (currentFilter === 'all') return true;
                return chat.mode === currentFilter;
            });

            console.log('üé® [RENDER-CHAT-LIST] Chats filtrados:', filteredChats.length);

            if (filteredChats.length === 0) {
                const emptyMessage = `
                    <div style="padding: 20px; text-align: center; color: #8b949e;">
                        <i class="fas fa-comments" style="font-size: 2em; margin-bottom: 10px;"></i>
                        <p>No hay chats ${currentFilter === 'all' ? '' : 'en modo ' + currentFilter}</p>
                        <small style="color: #666;">Chats totales en memoria: ${chats.size}</small>
                    </div>
                `;
                console.log('üé® [RENDER-CHAT-LIST] Mostrando mensaje vac√≠o');
                chatList.innerHTML = emptyMessage;
                return;
            }

            // Ordenar chats por √∫ltima actividad (m√°s recientes primero)
            const sortedChats = filteredChats.sort((a, b) => {
                const timeA = a.lastActivity || 0;
                const timeB = b.lastActivity || 0;
                return timeB - timeA; // Orden descendente (m√°s recientes primero)
            });

            // Solo loggear si hay chats para renderizar
            if (sortedChats.length > 0) {
                console.log(`üìã Renderizando ${sortedChats.length} chats ordenados por actividad`);
                // Log para depurar el √∫ltimo mensaje de cada chat
                sortedChats.forEach((chat, idx) => {
                    console.log(`üìã [RENDER] Chat ${idx}: ${chat.name} - √öltimo mensaje: "${chat.lastMessage}"`);
                });
            }

            chatList.innerHTML = sortedChats.map((chat, index) => {
                // *** NUEVA FUNCIONALIDAD: Mostrar informaci√≥n de mensajes ***
                const messagesInfo = chat.messagesCount > 0 ? 
                    `<div style="font-size: 0.7em; color: #0084ff; margin-top: 2px; font-weight: 500;">
                        üìö ${chat.messagesCount} mensajes cargados
                     </div>` : '';
                
                const unreadBadge = chat.unreadCount > 0 ? 
                    `<div style="position: absolute; top: 8px; right: 8px; background: #dc3545; color: white; border-radius: 50%; width: 18px; height: 18px; font-size: 0.7em; display: flex; align-items: center; justify-content: center; font-weight: bold;">${chat.unreadCount}</div>` : '';
                
                return `
                    <div class="chat-item ${chat.id === currentChatId ? 'active' : ''}" 
                         onclick="selectChat('${chat.id}')"
                         data-chat-id="${chat.id}"
                         data-chat-index="${index}"
                         data-messages-count="${chat.messagesCount || 0}">
                        <div class="chat-mode mode-${chat.mode}">${chat.mode === 'bot' ? 'BOT' : 'HUMANO'}</div>
                        ${unreadBadge}
                        <div class="chat-header">
                            <div class="chat-name">${chat.name}</div>
                            <div class="chat-time">${formatTime(chat.lastActivity)}</div>
                        </div>
                        <div class="chat-preview">${formatChatPreview(chat.lastMessage)}</div>
                        ${messagesInfo}
                    </div>
                `;
            }).join('');

            // *** SOLUCION: Asegurar que todos los chats sean visibles ***
            // Forzar rec√°lculo de altura despu√©s del render
            setTimeout(() => {
                const chatListElement = document.getElementById('chat-list');
                if (chatListElement) {
                    // Forzar un repaint/reflow para actualizar el scroll
                    chatListElement.style.height = 'auto';
                    const computedHeight = chatListElement.scrollHeight;
                    chatListElement.style.height = '';
                    
                    console.log(`üìè Lista de chats: ${sortedChats.length} elementos, altura: ${computedHeight}px`);
                    
                    // Si hay un chat activo, asegurar que sea visible
                    if (currentChatId) {
                        const activeChatElement = chatListElement.querySelector('.chat-item.active');
                        if (activeChatElement) {
                            activeChatElement.scrollIntoView({
                                behavior: 'smooth',
                                block: 'nearest',
                                inline: 'nearest'
                            });
                        }
                    }
                }
            }, 100);
        }

        function selectChat(chatId) {
            // Reiniciar hash de mensajes cuando se cambia de chat para permitir actualizaciones en tiempo real
            lastMessagesHash = '';
            currentChatId = chatId;
            const chat = chats.get(chatId);

            if (!chat) {
                console.error(`‚ùå Chat ${chatId} no encontrado`);
                return;
            }

            console.log(`üì± Seleccionando chat: ${chat.name} (${chatId}) - Dispositivo: ${window.innerWidth}px`);

            // Manejo espec√≠fico por tipo de dispositivo
            if (window.innerWidth <= 480) {
                // M√≥vil: Ocultar sidebar y mostrar chat
                const sidebar = document.getElementById('sidebar');
                const chatArea = document.getElementById('chat-area');
                const toggleBtn = document.getElementById('sidebar-toggle-btn');
                const icon = toggleBtn?.querySelector('i');

                sidebar.classList.remove('mobile-open');
                chatArea.classList.add('mobile-active');
                removeMobileOverlay();

                if (icon) {
                    icon.className = 'fas fa-bars';
                    toggleBtn.title = 'Mostrar Panel';
                }
            } else if (window.innerWidth <= 768) {
                // Tablet: L√≥gica existente
                const sidebar = document.getElementById('sidebar');
                const toggleBtn = document.getElementById('sidebar-toggle-btn');
                const icon = toggleBtn?.querySelector('i');

                sidebar.classList.remove('expanded');
                sidebar.classList.add('hidden');
                toggleBtn.classList.remove('slide-right');
                if (icon) {
                    icon.className = 'fas fa-bars';
                    toggleBtn.title = 'Mostrar Panel';
                }

                document.getElementById('chat-area').classList.add('fullscreen');
            }

            // Actualizar interfaz
            renderChatList();
            showChatArea(chat);

            // Marcar como le√≠do si tiene mensajes no le√≠dos
            if (chat.unreadCount > 0) {
                markAsRead(chatId);
            }

            // *** LAZY LOADING CON CACHE: Cargar mensajes viejos solo una vez ***
            // Verificar si los mensajes viejos ya fueron cargados para este chat
            if (loadedChatsCache.has(chatId) && chatMessagesCache.has(chatId)) {
                // Chat ya tiene mensajes cargados - mostrarlos inmediatamente desde el cach√©
                console.log(`üìã Chat ${chatId} ya tiene mensajes cargados - usando cach√©`);
                const cachedMessages = chatMessagesCache.get(chatId);
                displayMessages(cachedMessages, false, false); // No silencioso
                
                // Solo cargar nuevos mensajes si es necesario (sin forzar recarga completa)
                setTimeout(() => {
                    loadMessagesSmart(chatId, false); // false = no forzar, solo verificar nuevos mensajes
                }, 500);
            } else {
                // Primera carga de este chat - mostrar indicador y cargar mensajes viejos
                console.log(`üîÑ Primera carga para chat ${chatId} - cargando mensajes viejos...`);
                
                // Mostrar indicador de carga
                showLazyLoadingIndicator();
                
                // Cargar mensajes viejos por primera vez
                setTimeout(() => {
                    loadMessagesSmart(chatId, true); // true = forzar recarga completa
                }, 100);
            }

            // Asegurar que el polling est√© activo
            if (!messagePollingInterval) {
                console.log('‚ö†Ô∏è Polling no estaba activo, reiniciando...');
                startSmartMessagePolling();
            }

            // Configurar detecci√≥n de scroll para preservar UX
            setupScrollDetection();

            // Auto-scroll de la lista de chats para mostrar el chat seleccionado
            setTimeout(() => {
                const selectedChatElement = document.querySelector(`.chat-item[onclick="selectChat('${chatId}')"]`);
                if (selectedChatElement) {
                    selectedChatElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest',
                        inline: 'nearest'
                    });
                }
            }, 100);
        }

        function showChatArea(chat) {
            document.getElementById('empty-state').style.display = 'none';
            const chatArea = document.getElementById('chat-area');
            const sidebar = document.getElementById('sidebar');
            
            chatArea.style.display = 'flex';
            
            // Manejo espec√≠fico para m√≥viles
            if (window.innerWidth <= 480) {
                chatArea.classList.add('mobile-active');
                sidebar.classList.remove('mobile-open');
                removeMobileOverlay();
            }
            
            document.getElementById('current-chat-name').textContent = chat.name;
            document.getElementById('current-chat-subtitle').textContent = 
                `Modo ${chat.mode === 'bot' ? 'Bot' : 'Humano'} ÔøΩ ${chat.phone}`;
                
            const toggleBtn = document.getElementById('toggle-mode-btn');
            toggleBtn.innerHTML = chat.mode === 'bot' ? 
                '<i class="fas fa-user"></i> <span>Cambiar a Humano</span>' : 
                '<i class="fas fa-robot"></i> <span>Cambiar a Bot</span>';
        }

        // *** FUNCI√ìN DESHABILITADA: loadMessages ***
        // Esta funci√≥n estaba interfiriendo con loadMessagesSmart y cargando mensajes incompletos
        // Ahora usamos solo loadMessagesSmart que carga TODO el historial correctamente
        /*
        async function loadMessages(chatId) {
            try {
                const response = await fetch(`/api/chats/${chatId}/messages`);
                if (response.ok) {
                const data = await response.json();
                    displayMessages(data.messages || [], false, false); // No silencioso
                }
            } catch (error) {
                console.error('Error loading messages:', error);
            }
        }
        */



        // Funci√≥n para generar IDs √∫nicos para mensajes
        function generateMessageId(msg, index) {
            if (msg.id) return msg.id;
            if (msg.timestamp) return `msg-${msg.timestamp}-${index}`;
            return `msg-${Date.now()}-${index}`;
        }

        // Funci√≥n para guardar el estado de los elementos de audio
        function saveAudioStates() {
            const audioElements = document.querySelectorAll('audio');
            const audioStates = new Map();

            audioElements.forEach((audio, index) => {
                const messageElement = audio.closest('.message');
                if (messageElement) {
                    const messageId = messageElement.dataset.messageId || `audio-${index}`;

                    // Guardar estado de TODOS los audios que tengan progreso
                    if (audio.currentTime > 0) {
                        // Verificar m√°s precisamente si el audio est√° realmente reproduci√©ndose
                        const isActuallyPlaying = !audio.paused && audio.readyState >= 2 && !audio.ended;

                        audioStates.set(messageId, {
                            currentTime: audio.currentTime,
                            isPlaying: isActuallyPlaying,
                            volume: audio.volume,
                            muted: audio.muted,
                            src: audio.src,
                            duration: audio.duration,
                            playbackRate: audio.playbackRate,
                            timestamp: Date.now(),
                            readyState: audio.readyState,
                            ended: audio.ended
                        });

                        if (isActuallyPlaying) {
                            console.log(`üíæ Audio guardado: ${messageId} - Tiempo: ${audio.currentTime.toFixed(2)}s - Reproduci√©ndose activamente`);
                        } else if (!audio.paused) {
                            console.log(`üíæ Audio guardado: ${messageId} - Tiempo: ${audio.currentTime.toFixed(2)}s - Cargando...`);
                        } else {
                            console.log(`üíæ Audio guardado: ${messageId} - Tiempo: ${audio.currentTime.toFixed(2)}s - Pausado`);
                        }
                    }
                }
            });

            console.log(`üéµ Estados de audio guardados: ${audioStates.size} elementos`);
            return audioStates;
        }

        // Funci√≥n para restaurar el estado de los elementos de audio
        function restoreAudioStates(audioStates) {
            setTimeout(() => {
                const audioElements = document.querySelectorAll('audio');
                let restoredCount = 0;

                audioElements.forEach((audio, index) => {
                    const messageElement = audio.closest('.message');
                    if (messageElement) {
                        const messageId = messageElement.dataset.messageId || `audio-${index}`;
                        const savedState = audioStates.get(messageId);

                        if (savedState && savedState.src === audio.src) {
                            // Restaurar propiedades b√°sicas
                            audio.currentTime = savedState.currentTime;
                            audio.volume = savedState.volume;
                            audio.muted = savedState.muted;
                            audio.playbackRate = savedState.playbackRate || 1;

                            restoredCount++;

                            if (savedState.isPlaying) {
                                // Reanudar reproducci√≥n autom√°ticamente con un peque√±o delay
                                setTimeout(() => {
                                    audio.play().then(() => {
                                        console.log(`‚ñ∂Ô∏è Audio reanudado autom√°ticamente: ${messageId} - Posici√≥n: ${audio.currentTime.toFixed(2)}s`);
                                    }).catch(error => {
                                        console.log(`‚ö†Ô∏è No se pudo reanudar audio autom√°ticamente: ${messageId} - Error: ${error.message}`);
                                        console.log(`üí° El usuario puede hacer clic en play para continuar reproduciendo`);
                                    });
                                }, 50);

                                console.log(`üîÑ Audio restaurado y reanud√°ndose: ${messageId} - Posici√≥n: ${audio.currentTime.toFixed(2)}s`);
                            } else {
                                console.log(`‚úÖ Audio restaurado: ${messageId} - Posici√≥n: ${audio.currentTime.toFixed(2)}s - Estaba pausado`);
                            }
                        }
                    }
                });

                if (restoredCount > 0) {
                    console.log(`üéµ Estados de audio restaurados: ${restoredCount} elementos`);
                    console.log(`‚ñ∂Ô∏è Los audios que estaban reproduci√©ndose se reanudan autom√°ticamente`);
                    console.log(`üí° Si no se reanudan, verifica la configuraci√≥n de autoplay del navegador`);
                } else {
                    console.log(`‚ÑπÔ∏è No se encontraron audios para restaurar`);
                }
            }, 150);
        }

        function displayMessages(messages, preserveScrollPosition = false, silent = false) {
            const messagesArea = document.getElementById('messages-area');
            
            // Ocultar indicador de carga lazy si est√° presente
            hideLazyLoadingIndicator();

            if (!messages || messages.length === 0) {
                messagesArea.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #8b949e; text-align: center; padding: 20px;">
                        <i class="fas fa-comment-slash" style="font-size: 3em; margin-bottom: 15px; opacity: 0.5;"></i>
                        <p style="font-size: 1.1em; margin-bottom: 5px;">No hay mensajes en este chat</p>
                        <p style="font-size: 0.9em; opacity: 0.7;">Los mensajes aparecer√°n aqu√≠ cuando comience la conversaci√≥n</p>
                    </div>
                `;
                return;
            }

            // 1. Guardar posici√≥n de scroll si se solicita preservarla
            const currentScrollTop = preserveScrollPosition ? messagesArea.scrollTop : null;
            const currentScrollHeight = preserveScrollPosition ? messagesArea.scrollHeight : null;

            // 2. Guardar estado de audio ANTES de actualizar contenido
            const audioStates = saveAudioStates();

            // 3. Aumentar l√≠mite a 100 mensajes por chat para mejor experiencia en m√≥vil
            const limitedMessages = messages.length > 100 ? messages.slice(-100) : messages;
            
            // 4. Ordenar mensajes por timestamp para asegurar orden cronol√≥gico correcto
            const sortedMessages = [...limitedMessages].sort((a, b) => {
                const timestampA = a.timestamp || 0;
                const timestampB = b.timestamp || 0;
                return timestampA - timestampB;
            });

            // 4.5. Filtrar mensajes de API externa
            const filteredMessages = sortedMessages.filter(msg => {
                if (msg.isFromAPI) {
                    console.log(`üö´ [FILTER] Filtrando mensaje de API: "${msg.body.substring(0, 30)}"`);
                    return false;
                }
                return true;
            });
            
            if (messages.length > 100) {
                console.log(`‚ö†Ô∏è Mensajes limitados: ${messages.length} ‚Üí 100 (mostrando los √∫ltimos 100)`);
            }
            const apiMessagesCount = sortedMessages.length - filteredMessages.length;
            if (apiMessagesCount > 0) {
                console.log(`üö´ Mensajes de API filtrados: ${apiMessagesCount}`);
            }
            console.log(`üìù Mostrando ${filteredMessages.length} mensajes ordenados cronol√≥gicamente`);

            // 5. Actualizar contenido del chat con los mensajes filtrados (m√°ximo 50)
            messagesArea.innerHTML = filteredMessages.map((msg, index) => {
                const messageId = generateMessageId(msg, index);
                const messageClass = msg.fromMe ? 'outgoing' : 'incoming';
                const messageTime = formatTime(msg.timestamp);
                const messageStatus = msg.fromMe ? getMessageStatus(msg.status) : '';
                
                return `
                    <div class="message ${messageClass}" data-message-id="${messageId}" data-timestamp="${msg.timestamp}">
                        <div class="message-content">
                            <div class="message-text">${formatMessageBody(msg.body)}</div>
                            <div class="message-time">
                                ${messageTime}
                                ${msg.fromMe ? `<span class="message-status">${messageStatus}</span>` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // 5. Corregir URLs multimedia despu√©s de actualizar contenido
            fixMultimediaUrls();

            // 6. Restaurar estado de audio DESPU√âS de actualizar contenido
            restoreAudioStates(audioStates);

            // 7. Manejar scroll seg√∫n configuraci√≥n
            if (preserveScrollPosition && currentScrollTop !== null && currentScrollHeight !== null) {
                // Mantener posici√≥n relativa de scroll
                const newScrollHeight = messagesArea.scrollHeight;
                const heightDifference = newScrollHeight - currentScrollHeight;
                messagesArea.scrollTop = currentScrollTop + heightDifference;
                console.log(`üì± Scroll preservado: ${currentScrollTop} -> ${messagesArea.scrollTop}`);
            } else {
                // Scroll mejorado para m√≥viles
                requestAnimationFrame(() => {
                    const isMobile = window.innerWidth <= 768;
                    if (isMobile) {
                        // Para m√≥viles, usar m√∫ltiples intentos de scroll para asegurar funcionamiento
                        const scrollToBottom = () => {
                            messagesArea.scrollTop = messagesArea.scrollHeight;
                        };
                        
                        scrollToBottom();
                        setTimeout(scrollToBottom, 50);
                        setTimeout(scrollToBottom, 150);
                        
                        console.log(`üì± Scroll m√≥vil al final del chat (${filteredMessages.length} mensajes)`);
                    } else {
                        messagesArea.scrollTo({
                            top: messagesArea.scrollHeight,
                            behavior: 'smooth'
                        });
                        console.log(`üíª Scroll desktop al final del chat (${filteredMessages.length} mensajes)`);
                    }
                });
            }

            // 7. Agregar indicador de que se carg√≥ todo el historial
            if (filteredMessages.length > 0) {
                const firstMessage = filteredMessages[0];
                const lastMessage = filteredMessages[filteredMessages.length - 1];
                const dateRange = firstMessage.timestamp !== lastMessage.timestamp 
                    ? `${formatTime(firstMessage.timestamp)} - ${formatTime(lastMessage.timestamp)}`
                    : formatTime(firstMessage.timestamp);
                    
                console.log(`‚úÖ Historial completo cargado: ${sortedMessages.length} mensajes (${dateRange})`);
                
                // Opcional: mostrar indicador visual temporal (solo si no es silencioso)
                if (!silent) {
                    setTimeout(() => {
                        const indicator = document.createElement('div');
                        indicator.style.cssText = `
                            position: absolute;
                            top: 10px;
                            right: 10px;
                            background: rgba(0, 212, 170, 0.9);
                            color: white;
                            padding: 5px 10px;
                            border-radius: 15px;
                            font-size: 0.8em;
                            z-index: 100;
                            pointer-events: none;
                            opacity: 0;
                            transition: opacity 0.3s ease;
                        `;
                        indicator.innerHTML = `üìö ${sortedMessages.length} mensajes cargados`;
                        messagesArea.parentElement.style.position = 'relative';
                        messagesArea.parentElement.appendChild(indicator);

                        // Fade in y fade out
                        setTimeout(() => indicator.style.opacity = '1', 50);
                        setTimeout(() => {
                            indicator.style.opacity = '0';
                            setTimeout(() => indicator.remove(), 300);
                        }, 2000);
                    }, 100);
                }
            }
        }

        async function sendMessage() {
            const input = document.getElementById('message-input');
            const message = input.value.trim();

            if ((!message && selectedFiles.length === 0) || !currentChatId) return;

            const sendBtn = document.getElementById('send-btn');
            const originalContent = sendBtn.innerHTML;

            const restoreButton = () => {
                try {
                    sendBtn.innerHTML = originalContent;
                    sendBtn.disabled = false;
                } catch (error) {
                    console.error('Error restaurando botÔøΩn:', error);
                }
            };

            try {
                sendBtn.innerHTML = '<div class="loading"></div>';
                sendBtn.disabled = true;

                if (selectedFiles.length > 0) {
                    await sendFiles(message);
                } else if (message) {
                    const response = await fetch('/api/send-message', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chatId: currentChatId,
                            message: message
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        const webMessage = {
                            body: message,
                            fromMe: true,
                            timestamp: Date.now(),
                            status: 'sending',
                            isWebMessage: true
                        };

                        // Agregar al cache de mensajes web pendientes
                        if (!pendingWebMessages.has(currentChatId)) {
                            pendingWebMessages.set(currentChatId, []);
                        }
                        pendingWebMessages.get(currentChatId).push(webMessage);

                        addMessageToUI(webMessage);
                        showNotification('Mensaje enviado', 'success');

                        // Los mensajes enviados desde web ahora se mantienen permanentemente
                        console.log('‚úÖ [WEB MESSAGE] Mensaje enviado desde web agregado al UI');
                    } else {
                        const errorText = await response.text();
                        console.error('Error en respuesta:', errorText);
                        showNotification('Error enviando mensaje', 'error');
                    }
                }

                input.value = '';
                input.style.height = 'auto';
                clearFiles();

            } catch (error) {
                console.error('Error en sendMessage:', error);
                    showNotification('Error enviando mensaje', 'error');
            } finally {
                restoreButton();
            }
        }

        async function sendFiles(caption = '') {
            if (selectedFiles.length === 0) return;

            const formData = new FormData();
            formData.append('chatId', currentChatId);
            if (caption) formData.append('caption', caption);

            selectedFiles.forEach((file, index) => {
                formData.append('files', file);
            });

            try {
                const response = await fetch('/api/send-files', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();

                    selectedFiles.forEach(file => {
                            let content = '';
                            if (file.type.startsWith('image/')) {
                                const imageUrl = URL.createObjectURL(file);
                                content = `<img src="${imageUrl}" alt="${file.name}" style="max-width: 200px; border-radius: 8px;">`;
                            } else {
                            content = `?? ${file.name} (${formatFileSize(file.size)})`;
                            }

                            addMessageToUI({
                                body: content,
                                fromMe: true,
                                timestamp: Date.now(),
                                status: 'sending',
                                isMedia: true
                            });
                    });

                    if (caption) {
                            addMessageToUI({
                                body: caption,
                                fromMe: true,
                                timestamp: Date.now(),
                                status: 'sending'
                            });
                    }

                        showNotification(`${selectedFiles.length} archivo(s) enviado(s)`, 'success');
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Error desconocido' }));
                    showNotification(`Error enviando archivos: ${errorData.error}`, 'error');
                }
            } catch (error) {
                console.error('Error en sendFiles:', error);
                    showNotification('Error enviando archivos', 'error');
            }
        }

        function addMessageToUI(message) {
            const messagesArea = document.getElementById('messages-area');
            const messageElement = document.createElement('div');
            messageElement.className = `message ${message.fromMe ? 'outgoing' : 'incoming'}`;
            messageElement.dataset.messageId = message.id || `temp_${Date.now()}_${Math.random()}`;
            
            messageElement.innerHTML = `
                <div class="message-content">
                    <div class="message-text">${formatMessageBody(message.body)}</div>
                    <div class="message-time">
                        ${formatTime(message.timestamp)}
                        ${message.fromMe ? `<span class="message-status">${getMessageStatus(message.status)}</span>` : ''}
                    </div>
                </div>
            `;
            
            // Verificar si el mensaje ya existe para evitar duplicados
            const existingMessage = messagesArea.querySelector(`[data-message-id="${messageElement.dataset.messageId}"]`);
            if (existingMessage) {
                console.log('üîÑ Mensaje duplicado detectado, actualizando en lugar de agregar');
                existingMessage.replaceWith(messageElement);
            } else {
                messagesArea.appendChild(messageElement);
            }
            
            // Corregir URLs multimedia del nuevo mensaje
            fixMultimediaUrls();
            
            // Mejorar scroll para m√≥viles con requestAnimationFrame
            requestAnimationFrame(() => {
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    // En m√≥viles, usar smooth scroll con comportamiento m√°s confiable
                    messagesArea.scrollTo({
                        top: messagesArea.scrollHeight,
                        behavior: 'smooth'
                    });
                } else {
                    messagesArea.scrollTop = messagesArea.scrollHeight;
                }
                
                // Verificaci√≥n adicional para asegurar que el scroll funcion√≥
                setTimeout(() => {
                    if (messagesArea.scrollTop < messagesArea.scrollHeight - messagesArea.clientHeight - 50) {
                        console.log('üîß Corrigiendo scroll fallido');
                        messagesArea.scrollTop = messagesArea.scrollHeight;
                    }
                }, 100);
            });
        }

        async function toggleChatMode() {
            if (!currentChatId) return;
            
            try {
                const response = await fetch(`/api/chats/${currentChatId}/toggle-mode`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const chat = chats.get(currentChatId);
                    chat.mode = data.mode;
                    
                    showChatArea(chat);
                    renderChatList();
                    showNotification(`Modo cambiado a ${data.mode === 'bot' ? 'Bot' : 'Humano'}`, 'success');
                }
            } catch (error) {
                console.error('Error toggling mode:', error);
                showNotification('Error cambiando modo', 'error');
            }
        }

        async function endChat() {
            if (!currentChatId) return;
            
            if (!confirm('ÔøΩEstÔøΩs seguro de que quieres finalizar este chat?')) return;
            
            try {
                const response = await fetch(`/api/chats/${currentChatId}/end`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    chats.delete(currentChatId);
                    currentChatId = null;

                    // Detener auto-refresco cuando no hay chat activo
                    stopSmartMessagePolling();

                    document.getElementById('empty-state').style.display = 'flex';
                    document.getElementById('chat-area').style.display = 'none';

                    renderChatList();
                    showNotification('Chat finalizado', 'success');
                }
            } catch (error) {
                console.error('Error ending chat:', error);
                showNotification('Error finalizando chat', 'error');
            }
        }

        async function markAsRead(chatId) {
            try {
                await fetch(`/api/chats/${chatId}/mark-read`, { method: 'POST' });
                const chat = chats.get(chatId);
                if (chat) {
                    chat.unreadCount = 0;
                    renderChatList();
                }
            } catch (error) {
                console.error('Error marking as read:', error);
            }
        }

        function filterChats() {
            renderChatList();
        }

        async function showQRModal() {
            console.log('=== showQRModal() called ===');

            // Verificar si ya existe un modal QR superpuesto
            let overlayModal = document.getElementById('qr-overlay-modal');

            if (!overlayModal) {
                console.log('üì± Creando modal QR superpuesto...');

                // Crear modal superpuesto
                overlayModal = document.createElement('div');
                overlayModal.id = 'qr-overlay-modal';
                overlayModal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    animation: modalFadeIn 0.3s ease;
                    backdrop-filter: blur(3px);
                `;

                overlayModal.innerHTML = `
                    <div style="
                        background: white;
                        border-radius: 16px;
                        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                        max-width: 420px;
                        width: 90%;
                        max-height: 90vh;
                        overflow: hidden;
                        position: relative;
                        animation: modalSlideIn 0.4s ease;
                        transform: scale(0.9);
                        animation-fill-mode: forwards;
                    ">
                        <!-- Header -->
                        <div style="
                            background: linear-gradient(135deg, #25d366, #128c7e);
                            color: white;
                            padding: 20px 25px;
                            text-align: center;
                            position: relative;
                        ">
                            <button onclick="hideQROverlayModal()" style="
                                position: absolute;
                                top: 15px;
                                right: 15px;
                                background: rgba(255, 255, 255, 0.2);
                                border: none;
                                color: white;
                                font-size: 24px;
                                cursor: pointer;
                                padding: 5px 10px;
                                border-radius: 50%;
                                transition: all 0.2s ease;
                                width: 40px;
                                height: 40px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-weight: bold;
                            " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
                                √ó
                            </button>
                            <div style="margin-bottom: 12px;">
                                <i class="fab fa-whatsapp" style="font-size: 36px; opacity: 0.9;"></i>
                            </div>
                            <h2 style="margin: 0 0 8px 0; font-size: 22px; font-weight: 600;">
                                Escanear C√≥digo QR
                            </h2>
                            <p style="margin: 0; font-size: 14px; opacity: 0.9; line-height: 1.4;">
                                Escanea el c√≥digo QR con WhatsApp para conectar tu dispositivo
                            </p>
                        </div>

                        <!-- QR Content -->
                        <div style="padding: 30px;">
                            <div id="qr-overlay-code" style="
                                background: #f8f9fa;
                                border-radius: 12px;
                                padding: 25px;
                                margin-bottom: 20px;
                                min-height: 320px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                border: 2px dashed #e0e0e0;
                            ">
                                <div class="loading" style="
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    color: #666;
                                    flex-direction: column;
                                    text-align: center;
                                ">
                                    <div style="
                                        border: 4px solid #f3f3f3;
                                        border-top: 4px solid #25d366;
                                        border-radius: 50%;
                                        width: 45px;
                                        height: 45px;
                                        animation: spin 1s linear infinite;
                                        margin-bottom: 15px;
                                    "></div>
                                    <strong style="font-size: 16px; margin-bottom: 8px;">Cargando c√≥digo QR...</strong>
                                    <small style="color: #888;">Esto puede tomar unos segundos</small>
                                </div>
                            </div>

                            <!-- Instructions -->
                            <div style="
                                background: linear-gradient(135deg, #e3f2fd, #bbdefb);
                                border-radius: 10px;
                                padding: 18px;
                                font-size: 14px;
                                color: #1976d2;
                                border-left: 4px solid #2196f3;
                            ">
                                <strong style="color: #0d47a1;">üì± Instrucciones para escanear:</strong><br>
                                <div style="margin-top: 8px; line-height: 1.5;">
                                    1. Abre WhatsApp en tu tel√©fono<br>
                                    2. Toca ‚ãÆ > Dispositivos vinculados<br>
                                    3. Selecciona "Vincular dispositivo"<br>
                                    4. Escanea el c√≥digo QR de arriba
                                </div>
                            </div>

                            <!-- Bot√≥n de actualizar -->
                            <div style="
                                text-align: center;
                                margin-top: 15px;
                            ">
                                <button onclick="refreshQRImage()" style="
                                    background: linear-gradient(135deg, #25d366, #128c7e);
                                    color: white;
                                    border: none;
                                    padding: 8px 16px;
                                    border-radius: 6px;
                                    font-size: 12px;
                                    cursor: pointer;
                                    transition: all 0.2s ease;
                                    display: flex;
                                    align-items: center;
                                    margin: 0 auto;
                                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                    <i class="fas fa-sync-alt" style="margin-right: 5px;"></i>
                                    Actualizar QR
                                </button>
                            </div>

                            <!-- Footer -->
                            <div style="
                                text-align: center;
                                margin-top: 15px;
                                padding-top: 15px;
                                border-top: 1px solid #e0e0e0;
                                color: #666;
                                font-size: 12px;
                            ">
                                <i class="fas fa-info-circle" style="margin-right: 5px;"></i>
                                El modal se cerrar√° autom√°ticamente cuando te conectes
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(overlayModal);
                console.log('‚úÖ Modal QR superpuesto creado');
            }

            // Mostrar el modal
            overlayModal.style.display = 'flex';
            console.log('‚úÖ Modal QR superpuesto mostrado');

            // Cargar la imagen QR
            setTimeout(() => {
                loadQROverlayImage();
            }, 100);
        }

        async function loadQROverlayImage() {
            try {
                const qrCodeElement = document.getElementById('qr-overlay-code');
                if (!qrCodeElement) return;

                const response = await fetch('/api/qr');
                const data = await response.json();

                if (data.hasQR && data.qr) {
                    // Forzar actualizaci√≥n agresiva del cache
                    const timestamp = Date.now() + Math.random();
                    const cacheBuster = `t=${timestamp}&r=${Math.random().toString(36).substring(7)}`;
                    const qrImageUrl = `/api/qr-image?${cacheBuster}`;

                    console.log('üîó Cargando imagen QR con cache buster:', qrImageUrl);
                    console.log('üìä QR Data:', data.qr.substring(0, 30) + '...');

                    // Limpiar cualquier imagen anterior del cache
                    qrCodeElement.innerHTML = '';

                    // Crear contenedor para la imagen
                    const imageContainer = document.createElement('div');
                    imageContainer.style.textAlign = 'center';

                    // Crear la imagen con eventos para forzar actualizaci√≥n
                    const qrImage = document.createElement('img');
                    qrImage.src = qrImageUrl;
                    qrImage.alt = 'C√≥digo QR de WhatsApp';
                    qrImage.style.cssText = `
                        max-width: 100%;
                        max-height: 280px;
                        border-radius: 8px;
                        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
                        border: 3px solid white;
                        transition: opacity 0.3s ease;
                    `;

                    // Evento de carga exitosa
                    qrImage.onload = function() {
                        console.log('‚úÖ Imagen QR cargada exitosamente');
                        qrImage.style.opacity = '1';
                    };

                    // Evento de error - fallback a servicio externo
                    qrImage.onerror = function() {
                        console.log('‚ùå Error cargando imagen local, usando fallback...');
                        const fallbackUrl = `https://api.qrserver.com/v1/create-qr-code/?size=280x280&data=${encodeURIComponent(data.qr)}&${cacheBuster}`;
                        qrImage.src = fallbackUrl;
                    };

                    // Agregar la imagen al contenedor
                    imageContainer.appendChild(qrImage);

                    // Agregar instrucciones
                    const instructions = document.createElement('div');
                    instructions.style.cssText = `
                        margin-top: 15px;
                        font-size: 12px;
                        color: #666;
                    `;
                    instructions.innerHTML = `
                        <i class="fas fa-mobile-alt" style="margin-right: 5px;"></i>
                        Escanea con la c√°mara de WhatsApp
                        <br><small style="color: #999; font-size: 10px;">Actualizado: ${new Date().toLocaleTimeString()}</small>
                    `;
                    imageContainer.appendChild(instructions);

                    // Agregar al elemento principal
                    qrCodeElement.appendChild(imageContainer);

                    console.log('‚úÖ Imagen QR configurada para carga');
                } else {
                    qrCodeElement.innerHTML = `
                        <div style="
                            text-align: center;
                            color: #666;
                            padding: 20px;
                        ">
                            <i class="fas fa-clock" style="font-size: 32px; margin-bottom: 15px; opacity: 0.5;"></i>
                            <br><strong>Esperando c√≥digo QR...</strong>
                            <br><small>El c√≥digo se generar√° autom√°ticamente</small>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('‚ùå Error cargando imagen QR:', error);
                const qrCodeElement = document.getElementById('qr-overlay-code');
                if (qrCodeElement) {
                    qrCodeElement.innerHTML = `
                        <div style="
                            text-align: center;
                            color: #dc3545;
                            padding: 20px;
                        ">
                            <i class="fas fa-exclamation-triangle" style="font-size: 32px; margin-bottom: 15px;"></i>
                            <br><strong>Error cargando QR</strong>
                            <br><small>Int√©ntalo de nuevo</small>
                        </div>
                    `;
                }
            }
        }

        function hideQROverlayModal() {
            const modal = document.getElementById('qr-overlay-modal');
            if (modal) {
                modal.style.display = 'none';
                console.log('‚úÖ Modal QR superpuesto ocultado manualmente');
            }
        }

        // Funci√≥n para forzar actualizaci√≥n de la imagen QR
        function refreshQRImage() {
            const qrCodeElement = document.getElementById('qr-overlay-code');
            if (!qrCodeElement) return;

            console.log('üîÑ Forzando actualizaci√≥n de imagen QR...');

            // Limpiar contenido actual
            qrCodeElement.innerHTML = `
                <div style="
                    text-align: center;
                    color: #666;
                    padding: 20px;
                ">
                    <div style="
                        border: 4px solid #f3f3f3;
                        border-top: 4px solid #25d366;
                        border-radius: 50%;
                        width: 45px;
                        height: 45px;
                        animation: spin 1s linear infinite;
                        margin: 0 auto 15px auto;
                    "></div>
                    <strong>Actualizando c√≥digo QR...</strong>
                    <br><small>Forzando descarga nueva</small>
                </div>
            `;

            // Usar endpoint de actualizaci√≥n forzada
            setTimeout(() => {
                loadQROverlayImage(true); // true para forzar actualizaci√≥n
            }, 1000);
        }

        // Funci√≥n mejorada para cargar imagen QR con opci√≥n de forzar
        async function loadQROverlayImage(forceUpdate = false) {
            try {
                const qrCodeElement = document.getElementById('qr-overlay-code');
                if (!qrCodeElement) return;

                const response = await fetch('/api/qr');
                const data = await response.json();

                if (data.hasQR && data.qr) {
                    // Forzar actualizaci√≥n agresiva del cache
                    const timestamp = Date.now() + Math.random();
                    const cacheBuster = `t=${timestamp}&r=${Math.random().toString(36).substring(7)}`;

                    // Usar endpoint de actualizaci√≥n forzada si se solicita
                    const qrImageUrl = forceUpdate
                        ? `/api/qr-image/force?${cacheBuster}`
                        : `/api/qr-image?${cacheBuster}`;

                    console.log('üîó Cargando imagen QR:', qrImageUrl);
                    console.log('üìä QR Data:', data.qr.substring(0, 30) + '...');
                    console.log('üîÑ Modo forzar actualizaci√≥n:', forceUpdate);

                    // Limpiar cualquier imagen anterior del cache
                    qrCodeElement.innerHTML = '';

                    // Crear contenedor para la imagen
                    const imageContainer = document.createElement('div');
                    imageContainer.style.textAlign = 'center';

                    // Crear la imagen con eventos para forzar actualizaci√≥n
                    const qrImage = document.createElement('img');
                    qrImage.src = qrImageUrl;
                    qrImage.alt = 'C√≥digo QR de WhatsApp';
                    qrImage.style.cssText = `
                        max-width: 100%;
                        max-height: 280px;
                        border-radius: 8px;
                        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
                        border: 3px solid white;
                        transition: opacity 0.3s ease;
                    `;

                    // Evento de carga exitosa
                    qrImage.onload = function() {
                        console.log('‚úÖ Imagen QR cargada exitosamente');
                        qrImage.style.opacity = '1';
                    };

                    // Evento de error - fallback a servicio externo
                    qrImage.onerror = function() {
                        console.log('‚ùå Error cargando imagen local, usando fallback...');
                        const fallbackUrl = `https://api.qrserver.com/v1/create-qr-code/?size=280x280&data=${encodeURIComponent(data.qr)}&${cacheBuster}`;
                        qrImage.src = fallbackUrl;
                    };

                    // Agregar la imagen al contenedor
                    imageContainer.appendChild(qrImage);

                    // Agregar instrucciones
                    const instructions = document.createElement('div');
                    instructions.style.cssText = `
                        margin-top: 15px;
                        font-size: 12px;
                        color: #666;
                    `;
                    instructions.innerHTML = `
                        <i class="fas fa-mobile-alt" style="margin-right: 5px;"></i>
                        Escanea con la c√°mara de WhatsApp
                        <br><small style="color: #999; font-size: 10px;">Actualizado: ${new Date().toLocaleTimeString()}</small>
                        ${forceUpdate ? '<br><small style="color: #28a745; font-size: 10px;">üîÑ Actualizaci√≥n forzada</small>' : ''}
                    `;
                    imageContainer.appendChild(instructions);

                    // Agregar al elemento principal
                    qrCodeElement.appendChild(imageContainer);

                    console.log('‚úÖ Imagen QR configurada para carga');
                } else {
                    qrCodeElement.innerHTML = `
                        <div style="
                            text-align: center;
                            color: #666;
                            padding: 20px;
                        ">
                            <i class="fas fa-clock" style="font-size: 32px; margin-bottom: 15px; opacity: 0.5;"></i>
                            <br><strong>Esperando c√≥digo QR...</strong>
                            <br><small>El c√≥digo se generar√° autom√°ticamente</small>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('‚ùå Error cargando imagen QR:', error);
                const qrCodeElement = document.getElementById('qr-overlay-code');
                if (qrCodeElement) {
                    qrCodeElement.innerHTML = `

                        <div style="
                            text-align: center;
                            color: #dc3545;
                            padding: 20px;
                        ">
                            <i class="fas fa-exclamation-triangle" style="font-size: 32px; margin-bottom: 15px;"></i>
                            <br><strong>Error cargando QR</strong>
                            <br><small>Int√©ntalo de nuevo</small>
                        </div>
                    `;
                }
            }
        }

        // Agregar listener para la tecla Escape
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const overlayModal = document.getElementById('qr-overlay-modal');
                if (overlayModal && overlayModal.style.display !== 'none') {
                    hideQROverlayModal();
                    console.log('‚úÖ Modal QR cerrado con tecla Escape');
                }
            }
        });

        function hideQRModal() {
            const modal = document.getElementById('qr-modal');
            if (modal && !modal.classList.contains('hidden')) {
                modal.classList.add('hidden');
                console.log('QR modal hidden');
            }
        }

        // Funci√≥n mejorada para ocultar el modal QR con raz√≥n espec√≠fica
        function hideQRModalByConnection() {
            qrModalClosedByConnection = true;
            hideQRModal();

            // Tambi√©n ocultar el modal superpuesto si existe
            const overlayModal = document.getElementById('qr-overlay-modal');
            if (overlayModal) {
                overlayModal.style.display = 'none';
                console.log('‚úÖ Modal QR superpuesto ocultado por conexi√≥n exitosa');
            }

            console.log('QR modal hidden by successful connection');
        }

        function hideQRModalManually() {
            hideQRModal();
            console.log('QR modal hidden manually by user');
        }

        // Funci√≥n para forzar la ocultaci√≥n del modal QR si est√° visible por error
        function forceHideQRModal() {
            const modal = document.getElementById('qr-modal');
            if (modal && !modal.classList.contains('hidden')) {
                modal.classList.add('hidden');
                console.log('QR modal force hidden');
            }
        }

        // Funci√≥n para mostrar el modal QR forzosamente (para debugging)
        function forceShowQRModal() {
            console.log('Forcing QR modal show...');

            // Primero verificar si existe
            let modal = document.getElementById('qr-modal');

            if (!modal) {
                console.error('‚ùå Modal QR not found in DOM - creating emergency modal');

                // Crear modal de emergencia si no existe
                const emergencyModal = document.createElement('div');
                emergencyModal.id = 'qr-modal';
                emergencyModal.className = 'qr-modal';
                emergencyModal.style.cssText = `
                    position: fixed; top: 20px; right: 20px; width: 350px; height: auto;
                    background: white; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                    z-index: 1000; border: 2px solid #25d366; overflow: hidden;
                `;

                emergencyModal.innerHTML = `
                    <div style="padding: 20px; text-align: center; background: linear-gradient(135deg, #25d366, #128c7e); color: white; position: relative;">
                        <button onclick="hideQRModalManually()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 5px;">&times;</button>
                        <h3 style="margin: 0 0 10px 0; font-size: 18px;"><i class="fab fa-whatsapp"></i> Modal QR de Emergencia</h3>
                        <p style="margin: 0; font-size: 14px; opacity: 0.9;">Modal creado por emergencia - recarga la p√°gina</p>
                    </div>
                    <div style="padding: 20px;">
                        <div style="text-align: center; padding: 30px; background: #f8f9fa; border-radius: 8px;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 24px; color: #dc3545; margin-bottom: 10px;"></i>
                            <br><strong>Modal QR no encontrado</strong>
                            <br><small>Recarga la p√°gina para solucionarlo</small>
                        </div>
                    </div>
                `;

                document.body.appendChild(emergencyModal);
                modal = emergencyModal;
                console.log('‚úÖ Emergency modal created');
            }

            // Mostrar el modal
            if (modal.classList.contains('hidden')) {
                modal.classList.remove('hidden');
                console.log('‚úÖ QR modal forced to show');

                // Intentar cargar el QR si hay elementos
                const qrCode = document.getElementById('qr-code');
                if (qrCode) {
                    showQRModal();
                }
            } else {
                console.log('‚ÑπÔ∏è QR modal was already visible');
            }
        }

        // Funci√≥n para inicializar el bot√≥n QR
        function initializeQRButton() {
            const qrBtn = document.getElementById('qr-btn');
            if (qrBtn) {
                qrBtn.addEventListener('click', function() {
                    console.log('QR button clicked - showing QR modal');
                    showQRModal();
                });
                console.log('‚úÖ QR button initialized');
            } else {
                console.error('‚ùå QR button not found in DOM');
            }
        }

        // Funci√≥n para inicializar el bot√≥n de escanear QR
        function initializeScanQRButton() {
            const scanQrBtn = document.getElementById('scan-qr-btn');
            if (scanQrBtn) {
                scanQrBtn.addEventListener('click', handleScanQRClick);
                console.log('‚úÖ Scan QR button initialized');
            } else {
                console.error('‚ùå Scan QR button not found in DOM');
            }
        }

        // Variables para el contador de sesi√≥n
        let sessionDuration = 15 * 60 * 1000; // 15 minutos en milisegundos
        let sessionStartTime = null;
        let sessionTimer = null;
        let sessionWarningShown = false;
        let sessionCriticalShown = false;
        let lastActivityTime = Date.now();

        // Funci√≥n para inicializar el contador de sesi√≥n
        function initializeSessionCounter() {
            const sessionCounter = document.getElementById('session-counter');
            if (sessionCounter) {
                sessionStartTime = Date.now();
                lastActivityTime = Date.now();
                sessionWarningShown = false;
                sessionCriticalShown = false;

                // Hacer el contador clickeable para extender la sesi√≥n
                sessionCounter.addEventListener('click', extendSessionManually);
                sessionCounter.style.cursor = 'pointer';
                sessionCounter.title = 'Click para extender la sesi√≥n';

                // Iniciar el contador
                startSessionTimer();

                // Configurar detectores de actividad
                setupActivityDetection();

                console.log('‚úÖ Session counter initialized');
            } else {
                console.error('‚ùå Session counter element not found in DOM');
            }
        }

        // Funci√≥n para iniciar el temporizador de sesi√≥n
        function startSessionTimer() {
            if (sessionTimer) {
                clearInterval(sessionTimer);
            }

            sessionTimer = setInterval(() => {
                const elapsed = Date.now() - lastActivityTime;
                const remaining = sessionDuration - elapsed;

                if (remaining <= 0) {
                    // Sesi√≥n expirada
                    handleSessionExpired();
                    return;
                }

                // Actualizar el contador visual
                updateSessionCounter(remaining);
            }, 1000); // Actualizar cada segundo
        }

        // Funci√≥n para actualizar el contador visual
        function updateSessionCounter(remainingMs) {
            const sessionTime = document.getElementById('session-time');
            const sessionCounter = document.getElementById('session-counter');

            if (!sessionTime || !sessionCounter) return;

            const minutes = Math.floor(remainingMs / (60 * 1000));
            const seconds = Math.floor((remainingMs % (60 * 1000)) / 1000);

            // Formato MM:SS
            const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            sessionTime.textContent = timeString;

            // Cambiar colores seg√∫n el tiempo restante
            const totalMinutes = sessionDuration / (60 * 1000);
            const remainingMinutes = remainingMs / (60 * 1000);

            // Remover clases anteriores
            sessionCounter.classList.remove('warning', 'critical');

            if (remainingMinutes <= 2) {
                // Menos de 2 minutos - Estado cr√≠tico
                sessionCounter.classList.add('critical');
                if (!sessionCriticalShown) {
                    showNotification('¬°Sesi√≥n expira en menos de 2 minutos!', 'error');
                    sessionCriticalShown = true;
                }
            } else if (remainingMinutes <= 5) {
                // Menos de 5 minutos - Estado de advertencia
                sessionCounter.classList.add('warning');
                if (!sessionWarningShown) {
                    showNotification('Sesi√≥n expira en menos de 5 minutos', 'warning');
                    sessionWarningShown = true;
                }
            }
        }

        // Funci√≥n para detectar actividad del usuario
        function setupActivityDetection() {
            const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];

            const resetTimer = () => {
                lastActivityTime = Date.now();
                // Reiniciar banderas de advertencia cuando hay actividad
                if (sessionWarningShown || sessionCriticalShown) {
                    sessionWarningShown = false;
                    sessionCriticalShown = false;
                    console.log('Session timer reset due to user activity');
                }
            };

            events.forEach(event => {
                document.addEventListener(event, resetTimer, true);
            });

            console.log('‚úÖ Activity detection setup completed');
        }

        // Funci√≥n para manejar cuando la sesi√≥n expira
        function handleSessionExpired() {
            console.log('‚è∞ Session expired - redirecting to login');

            // Limpiar el temporizador
            if (sessionTimer) {
                clearInterval(sessionTimer);
                sessionTimer = null;
            }

            // Mostrar notificaci√≥n final
            showNotification('Tu sesi√≥n ha expirado. Ser√°s redirigido al login.', 'error');

            // Esperar 3 segundos antes de redirigir
            setTimeout(() => {
                // Limpiar la sesi√≥n
                token = null;
                currentUser = null;
                localStorage.removeItem('token');

                // Redirigir al login
                showLoginScreen();
            }, 3000);
        }

        // Funci√≥n para extender manualmente la sesi√≥n
        function extendSessionManually() {
            console.log('üîÑ Extending session manually...');
            lastActivityTime = Date.now();
            sessionWarningShown = false;
            sessionCriticalShown = false;

            // Actualizar el contador inmediatamente
            const sessionCounter = document.getElementById('session-counter');
            if (sessionCounter) {
                sessionCounter.classList.remove('warning', 'critical');
            }

            showNotification('Sesi√≥n extendida por actividad', 'success');
        }

        // Funci√≥n para actualizar la visibilidad del bot√≥n QR
        function updateQRButtonVisibility() {
            const qrBtn = document.getElementById('qr-btn');
            if (qrBtn) {
                if (isConnected) {
                    qrBtn.style.display = 'none';
                    console.log('QR button hidden - WhatsApp connected');
                } else {
                    qrBtn.style.display = 'flex';
                    console.log('QR button shown - WhatsApp not connected');
                }
            }
        }

        // Funci√≥n para actualizar la visibilidad del bot√≥n de escanear QR
        let lastScanQRButtonState = null;

        function updateScanQRButtonVisibility() {
            const scanQrBtn = document.getElementById('scan-qr-btn');
            if (scanQrBtn) {
                const shouldShow = !isConnected;
                
                // Solo actualizar si el estado cambi√≥
                if (lastScanQRButtonState !== shouldShow) {
                    if (shouldShow) {
                        scanQrBtn.style.display = 'flex';
                        console.log('Scan QR button shown - WhatsApp not connected');
                    } else {
                        scanQrBtn.style.display = 'none';
                        console.log('Scan QR button hidden - WhatsApp connected');
                    }
                    lastScanQRButtonState = shouldShow;
                }
            }
        }

        // Funci√≥n para manejar el clic en el bot√≥n de escanear QR
        function handleScanQRClick() {
            console.log('üîç === ESCANEAR QR BUTTON CLICKED ===');
            console.log('Current connection status:', isConnected);
            console.log('QR modal closed by connection flag:', qrModalClosedByConnection);

            // Mostrar informaci√≥n del QR en consola
            fetch('/api/qr')
                .then(response => response.json())
                .then(data => {
                    console.log('üì± === QR CODE INFORMATION ===');
                    console.log('QR Available:', data.hasQR);
                    if (data.hasQR && data.qr) {
                        console.log('QR Data:', data.qr);
                        console.log('üîó QR Local URL:', `/api/qr-image?t=${Date.now()}`);
                        console.log('üåê QR External URL:', `https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodeURIComponent(data.qr)}`);
                        console.log('üì± ¬°La imagen QR aparecer√° en la ventana modal!');
                    } else {
                        console.log('No QR data available');
                    }
                })
                .catch(error => {
                    console.error('Error fetching QR data:', error);
                });

            // Mostrar el modal QR
            showQRModal();

            // Mostrar notificaci√≥n
            showNotification('Escanea el c√≥digo QR que aparece en la ventana modal', 'info');

            // Iniciar monitoreo de conexi√≥n
            startQRConnectionMonitoring();
        }

        // Variable para controlar el monitoreo de conexi√≥n
        let qrConnectionMonitoring = false;

        // Funci√≥n para monitorear la conexi√≥n de WhatsApp mientras el modal QR est√° abierto
        function startQRConnectionMonitoring() {
            if (qrConnectionMonitoring) {
                return; // Ya est√° monitoreando
            }

            qrConnectionMonitoring = true;
            console.log('üîÑ Starting QR connection monitoring...');

            const monitoringInterval = setInterval(() => {
                const qrModal = document.getElementById('qr-modal');

                // Si el modal ya no est√° visible, detener el monitoreo
                if (!qrModal || qrModal.classList.contains('hidden')) {
                    clearInterval(monitoringInterval);
                    qrConnectionMonitoring = false;
                    console.log('‚úÖ QR connection monitoring stopped - modal closed');
                    return;
                }

                // Verificar estado de conexi√≥n
                fetch('/api/stats')
                    .then(response => response.json())
                    .then(data => {
                        const isWhatsAppReady = data.whatsappListo || data.connected || data.ready;

                        if (isWhatsAppReady && !isConnected) {
                            console.log('üéâ WhatsApp connected! Closing QR modal...');

                            // Actualizar estado
                            isConnected = true;
                            qrModalClosedByConnection = true;

                            // Actualizar botones
                            updateQRButtonVisibility();
                            updateScanQRButtonVisibility();

                            // Mostrar notificaci√≥n
                            showNotification('¬°WhatsApp conectado exitosamente!', 'success');

                            // Cerrar modal despu√©s de 2 segundos
                            setTimeout(() => {
                                hideQRModalByConnection();
                                clearInterval(monitoringInterval);
                                qrConnectionMonitoring = false;
                                console.log('‚úÖ QR modal closed automatically after connection');
                            }, 2000);
                        }
                    })
                    .catch(error => {
                        console.error('Error checking connection during QR monitoring:', error);
                    });
            }, 1000); // Verificar cada segundo
        }

        // Funci√≥n para verificar que el modal QR existe en el DOM
        function checkQRModalInDOM() {
            const modal = document.getElementById('qr-modal');
            const qrCode = document.getElementById('qr-code');

            console.log('=== QR MODAL DOM CHECK ===');
            console.log('Modal element exists:', !!modal);
            console.log('QR code element exists:', !!qrCode);

            if (modal) {
                console.log('Modal classes:', modal.classList.toString());
                console.log('Modal computed style display:', window.getComputedStyle(modal).display);
                console.log('Modal is hidden:', modal.classList.contains('hidden'));
            }

            if (qrCode) {
                console.log('QR code innerHTML:', qrCode.innerHTML.substring(0, 100) + '...');
            }

            // Verificar elementos relacionados
            const allElementsWithQR = Array.from(document.querySelectorAll('[id*="qr"], [class*="qr"]'));
            console.log('Elements with QR in id/class:', allElementsWithQR.map(el => ({id: el.id, class: el.className})));

            return {
                modalExists: !!modal,
                qrCodeExists: !!qrCode,
                modalHidden: modal ? modal.classList.contains('hidden') : null
            };
        }

        // Exponer funci√≥n de verificaci√≥n DOM
        window.checkQRModalInDOM = checkQRModalInDOM;

        // Funci√≥n para verificar el modal QR al cargar la p√°gina
        function verifyQRModalOnLoad() {
            console.log('=== PAGE LOAD - QR MODAL VERIFICATION ===');
            const result = checkQRModalInDOM();

            if (result.modalExists && result.qrCodeExists) {
                console.log('‚úÖ QR modal components found and ready');
            } else {
                console.error('‚ùå QR modal components missing!');
                if (!result.modalExists) console.error('   - Modal element not found');
                if (!result.qrCodeExists) console.error('   - QR code element not found');
            }

            return result;
        }

        // Ejecutar verificaci√≥n cuando el DOM est√© listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', verifyQRModalOnLoad);
        } else {
            verifyQRModalOnLoad();
        }

        // Tambi√©n verificar cuando la ventana est√© completamente cargada
        window.addEventListener('load', function() {
            console.log('=== WINDOW LOAD - QR MODAL FINAL CHECK ===');
            setTimeout(verifyQRModalOnLoad, 100); // Peque√±o delay para asegurar que todo est√© listo
        });

        // Funci√≥n para actualizar el indicador de estado en el modal QR
        function updateQRStatusIndicator(status, message) {
            const indicator = document.getElementById('qr-status-indicator');
            if (indicator) {
                indicator.innerHTML = message;

                // Cambiar colores seg√∫n el estado
                switch(status) {
                    case 'connecting':
                        indicator.style.background = '#fff3cd';
                        indicator.style.color = '#856404';
                        indicator.style.borderColor = '#ffeaa7';
                        break;
                    case 'connected':
                        indicator.style.background = '#d4edda';
                        indicator.style.color = '#155724';
                        indicator.style.borderColor = '#c3e6cb';
                        break;
                    case 'error':
                        indicator.style.background = '#f8d7da';
                        indicator.style.color = '#721c24';
                        indicator.style.borderColor = '#f5c6cb';
                        break;
                }
            }
        }

        // Funci√≥n de debugging para el modal QR
        function debugQRModal() {
            const modal = document.getElementById('qr-modal');
            const isVisible = modal && !modal.classList.contains('hidden');
            const isConnectedStatus = isConnected;

            console.log('=== DEBUG QR MODAL ===');
            console.log('Modal visible:', isVisible);
            console.log('WhatsApp connected:', isConnectedStatus);
            console.log('QR modal closed by connection:', qrModalClosedByConnection);
            console.log('Modal element:', modal);
            console.log('Modal classes:', modal ? modal.classList.toString() : 'null');
            console.log('Connection check interval running:', true);

            // Verificar estado de conexi√≥n actual
            fetch('/api/stats')
                .then(response => response.json())
                .then(data => {
                    console.log('Current connection status:', data);
                    const isWhatsAppReady = data.whatsappListo || data.connected || data.ready;
                    console.log('Calculated ready status:', isWhatsAppReady);
                })
                .catch(error => console.error('Error fetching connection status:', error));

            return {
                isVisible,
                isConnected: isConnectedStatus,
                qrModalClosedByConnection
            };
        }

        // Funci√≥n de diagn√≥stico completa para el modal QR
        function diagnoseQRModal() {
            console.log('üîç === DIAGN√ìSTICO COMPLETO DEL MODAL QR ===');

            const modal = document.getElementById('qr-modal');
            const isVisible = modal && !modal.classList.contains('hidden');
            const indicator = document.getElementById('qr-status-indicator');

            console.log('üìä Estado actual:');
            console.log('   - Modal existe:', !!modal);
            console.log('   - Modal visible:', isVisible);
            console.log('   - WhatsApp conectado:', isConnected);
            console.log('   - Flag cerrado por conexi√≥n:', qrModalClosedByConnection);
            console.log('   - Indicador de estado:', indicator ? indicator.innerHTML : 'No encontrado');
            console.log('   - Modal classes:', modal ? modal.classList.toString() : 'null');

            // Verificar elementos del DOM
            const qrCode = document.getElementById('qr-code');
            console.log('   - QR code element exists:', !!qrCode);
            console.log('   - QR code has content:', qrCode ? qrCode.innerHTML.length > 0 : 'N/A');

            // Verificar conexi√≥n actual
            fetch('/api/stats')
                .then(response => response.json())
                .then(data => {
                    const isWhatsAppReady = data.whatsappListo || data.connected || data.ready;
                    console.log('üîó Estado de WhatsApp:');
                    console.log('   - whatsappListo:', data.whatsappListo);
                    console.log('   - connected:', data.connected);
                    console.log('   - ready:', data.ready);
                    console.log('   - Calculado ready:', isWhatsAppReady);

                    console.log('üìã Diagn√≥stico:');
                    if (isWhatsAppReady && isConnected && qrModalClosedByConnection) {
                        console.log('   ‚úÖ TODO CORRECTO: WhatsApp conectado y modal cerrado por conexi√≥n exitosa');
                    } else if (isWhatsAppReady && !isConnected) {
                        console.log('   ‚ö†Ô∏è  WhatsApp conectado pero isConnected=false (posible problema de sincronizaci√≥n)');
                        console.log('   üí° Soluci√≥n: Ejecuta forceConnectionCheck()');
                    } else if (!isWhatsAppReady && isConnected) {
                        console.log('   ‚ö†Ô∏è  isConnected=true pero WhatsApp no est√° listo (estado inconsistente)');
                        console.log('   üí° Soluci√≥n: Ejecuta forceConnectionCheck()');
                    } else if (!isModalVisible && !qrModalClosedByConnection) {
                        console.log('   ‚ö†Ô∏è  Modal oculto pero no por conexi√≥n exitosa (posible cierre manual)');
                        console.log('   üí° Soluci√≥n: Ejecuta resetQRModalFlag() si necesitas que aparezca de nuevo');
                    } else if (isModalVisible && isWhatsAppReady) {
                        console.log('   ‚ö†Ô∏è  Modal visible pero WhatsApp conectado (deber√≠a cerrarse)');
                        console.log('   üí° Soluci√≥n: Ejecuta forceConnectionCheck()');
                    } else if (!isVisible && !qrModalClosedByConnection) {
                        console.log('   ‚ö†Ô∏è  Modal no est√° visible y no se cerr√≥ por conexi√≥n exitosa');
                        console.log('   üí° Posibles causas:');
                        console.log('      - Modal nunca se mostr√≥ despu√©s del login');
                        console.log('      - Error en showQRModal()');
                        console.log('      - Problema de timing');
                        console.log('   üîß Soluciones:');
                        console.log('      - Ejecuta checkQRModalInDOM() para verificar elementos');
                        console.log('      - Ejecuta forceShowQRModal() para mostrar forzosamente');
                        console.log('      - Recarga la p√°gina si el modal no existe');
                    } else if (!modal) {
                        console.log('   ‚ùå CR√çTICO: Modal QR no existe en el DOM');
                        console.log('   üí° Soluci√≥n: Recarga la p√°gina');
                    } else {
                        console.log('   ‚ùì Estado desconocido - revisa logs anteriores');
                    }

                    console.log('üõ†Ô∏è  Comandos disponibles:');
                    console.log('   - debugQRModal(): Ver estado detallado');
                    console.log('   - checkQRModalInDOM(): Verificar elementos en DOM');
                    console.log('   - forceConnectionCheck(): Forzar verificaci√≥n de conexi√≥n');
                    console.log('   - resetQRModalFlag(): Permitir que el modal aparezca de nuevo');
                    console.log('   - forceShowQRModal(): Mostrar modal forzosamente');
                    console.log('   - forceCloseQRModal(): Cerrar modal forzosamente');
                })
                .catch(error => {
                    console.error('‚ùå Error al obtener estado de conexi√≥n:', error);
                });
        }

        // Exponer funci√≥n de diagn√≥stico
        window.diagnoseQRModal = diagnoseQRModal;

        // Funci√≥n para probar el nuevo flujo del bot√≥n QR
        function testQRButtonFlow() {
            console.log('=== TESTING QR BUTTON FLOW ===');

            // Simular secuencia: mostrar bot√≥n ‚Üí hacer clic ‚Üí mostrar modal ‚Üí conectar ‚Üí cerrar modal y bot√≥n
            console.log('1. Testing QR button initialization...');
            initializeQRButton();

            setTimeout(() => {
                console.log('2. Simulating WhatsApp disconnection (button should appear)...');
                isConnected = false;
                updateQRButtonVisibility();

                setTimeout(() => {
                    console.log('3. Simulating WhatsApp connection (button should disappear)...');
                    isConnected = true;
                    qrModalClosedByConnection = true;
                    updateQRButtonVisibility();
                    console.log('‚úÖ QR button flow test completed');
                }, 2000);
            }, 1000);
        }

        // Exponer funci√≥n de prueba del bot√≥n QR
        window.testQRButtonFlow = testQRButtonFlow;

        // Exponer funci√≥n de debugging globalmente
        window.debugQRModal = debugQRModal;

        // Funci√≥n para forzar verificaci√≥n de conexi√≥n
        function forceConnectionCheck() {
            console.log('Forcing connection check...');
            checkConnectionStatus();
        }

        // Funci√≥n para forzar cierre del modal QR
        function forceCloseQRModal() {
            console.log('Forcing QR modal close...');
            hideQRModalManually();
        }

        // Funci√≥n para resetear el flag del modal QR (permitir que aparezca de nuevo)
        function resetQRModalFlag() {
            qrModalClosedByConnection = false;
            console.log('QR modal flag reset - modal can appear again if needed');
        }

        // Exponer funciones adicionales globalmente
        window.forceConnectionCheck = forceConnectionCheck;
        window.forceCloseQRModal = forceCloseQRModal;
        window.resetQRModalFlag = resetQRModalFlag;
        window.forceShowQRModal = forceShowQRModal;

        // Funci√≥n de prueba para simular conexi√≥n (solo para debugging)
        function testQRConnection() {
            console.log('=== TESTING QR CONNECTION LOGIC ===');

            // Resetear flag antes de la prueba
            qrModalClosedByConnection = false;

            // Simular estado de conexi√≥n
            isConnected = true;

            // Verificar si el modal se cierra correctamente
            const qrModal = document.getElementById('qr-modal');
            if (qrModal && !qrModal.classList.contains('hidden')) {
                updateQRStatusIndicator('connected', '<i class="fas fa-check-circle"></i> ¬°WhatsApp conectado! La ventana se cerrar√° autom√°ticamente...');
                showNotification('¬°WhatsApp conectado exitosamente!', 'success');

                setTimeout(() => {
                    hideQRModalManually(); // Usar cierre manual para pruebas
                    console.log('‚úÖ Test successful - Modal closed automatically');
                }, 2000);
            } else {
                console.log('‚ÑπÔ∏è Test info - Modal was already hidden');
            }
        }

        // Exponer funci√≥n de prueba
        window.testQRConnection = testQRConnection;

        // Exponer funciones del bot√≥n de escanear QR
        window.handleScanQRClick = handleScanQRClick;
        window.updateScanQRButtonVisibility = updateScanQRButtonVisibility;

        // Funci√≥n para probar el flujo completo del modal QR
        function testQRFlow() {
            console.log('=== TESTING COMPLETE QR FLOW ===');

            // Resetear flag antes de la prueba
            qrModalClosedByConnection = false;

            // Simular secuencia: login -> mostrar modal -> conectar -> cerrar modal
            console.log('1. Showing QR modal (simulating login)');
            showQRModal();
            updateQRStatusIndicator('connecting', '<i class="fas fa-spinner fa-spin"></i> Esperando conexi√≥n de WhatsApp...');

            setTimeout(() => {
                console.log('2. Simulating WhatsApp connection');
                isConnected = true;

                // Simular la l√≥gica de checkConnectionStatus cuando WhatsApp se conecta
                const qrModal = document.getElementById('qr-modal');
                const isModalVisible = qrModal && !qrModal.classList.contains('hidden');

                if (isModalVisible) {
                    console.log('3. Modal is visible - updating status and scheduling close');
                    updateQRStatusIndicator('connected', '<i class="fas fa-check-circle"></i> ¬°WhatsApp conectado! La ventana se cerrar√° autom√°ticamente...');
                    showNotification('¬°WhatsApp conectado exitosamente!', 'success');

                    setTimeout(() => {
                        console.log('4. Auto-closing modal after 2 seconds');
                        hideQRModalManually(); // Usar cierre manual para pruebas
                        console.log('‚úÖ QR flow test completed successfully');
                    }, 2000);
                } else {
                    console.log('‚ùå Modal was not visible during connection test');
                }
            }, 3000);
        }

        // Exponer funci√≥n de prueba de flujo completo
        window.testQRFlow = testQRFlow;

        // Funci√≥n para probar el bot√≥n de escanear QR
        function testScanQRButton() {
            console.log('=== TESTING SCAN QR BUTTON ===');

            // Simular secuencia: mostrar bot√≥n ‚Üí hacer clic ‚Üí mostrar modal ‚Üí conectar ‚Üí cerrar modal y bot√≥n
            console.log('1. Testing scan QR button initialization...');
            initializeScanQRButton();

            setTimeout(() => {
                console.log('2. Simulating WhatsApp disconnection (scan QR button should appear)...');
                isConnected = false;
                updateScanQRButtonVisibility();

                setTimeout(() => {
                    console.log('3. Simulating manual QR scan button click...');
                    handleScanQRClick();

                    setTimeout(() => {
                        console.log('4. Simulating WhatsApp connection (scan QR button should disappear)...');
                        isConnected = true;
                        qrModalClosedByConnection = true;
                        updateScanQRButtonVisibility();
                        console.log('‚úÖ Scan QR button flow test completed');
                    }, 3000);
                }, 2000);
            }, 1000);
        }

        // Exponer funci√≥n de prueba del bot√≥n de escanear QR
        window.testScanQRButton = testScanQRButton;

        // Funci√≥n de ayuda para el usuario sobre el bot√≥n de escanear QR
        function helpScanQRButton() {
            console.log('üöÄ === AYUDA: BOT√ìN ESCANEAR QR ===');
            console.log('');
            console.log('üìç ¬øD√≥nde est√° el bot√≥n?');
            console.log('   - En el header, al lado del bot√≥n de informaci√≥n del usuario');
            console.log('   - Tiene un √≠cono de c√≥digo QR y dice "Escanear QR"');
            console.log('   - Color verde con gradiente WhatsApp');
            console.log('');
            console.log('‚ö° ¬øQu√© hace cuando lo presionas?');
            console.log('   1. Muestra informaci√≥n del QR en la consola');
            console.log('   2. Abre la ventana modal con el c√≥digo QR');
            console.log('   3. Inicia monitoreo autom√°tico de conexi√≥n');
            console.log('   4. Cierra autom√°ticamente cuando WhatsApp se conecta');
            console.log('');
            console.log('üîÑ ¬øCu√°ndo aparece/desaparece?');
            console.log('   ‚úÖ Aparece: Cuando WhatsApp est√° desconectado');
            console.log('   ‚ùå Desaparece: Cuando WhatsApp est√° conectado');
            console.log('');
            console.log('üõ†Ô∏è Comandos √∫tiles:');
            console.log('   - testScanQRButton(): Probar el flujo completo');
            console.log('   - debugQRModal(): Ver estado actual');
            console.log('   - diagnoseQRModal(): Diagn√≥stico completo');
            console.log('');
            console.log('üí° Tip: El bot√≥n monitorea la conexi√≥n cada segundo mientras el modal est√° abierto');
        }

        // Exponer funci√≥n de ayuda
        window.helpScanQRButton = helpScanQRButton;

        // Funci√≥n para interceptar y debuggear el mensaje "no hay sesi√≥n activa"
        function debugSessionMessage() {
            console.log('üîç === DEBUGGING SESSION MESSAGE ===');
            console.log('Current session state:');
            console.log('- token:', token);
            console.log('- currentUser:', currentUser);
            console.log('- localStorage token:', localStorage.getItem('token'));

            // Interceptar showNotification para capturar el mensaje
            const originalShowNotification = window.showNotification;
            window.showNotification = function(message, type) {
                console.log('üîî NOTIFICATION INTERCEPTED:', { message, type });

                // Si es el mensaje problem√°tico, mostrar stack trace
                if (message.toLowerCase().includes('sesi√≥n') ||
                    message.toLowerCase().includes('session') ||
                    message.toLowerCase().includes('activa')) {
                    console.error('‚ùå SESSION MESSAGE DETECTED!');
                    console.trace('Stack trace:');
                }

                return originalShowNotification.apply(this, arguments);
            };

            console.log('‚úÖ Notification interception active');
            console.log('üí° Now try to reproduce the issue and check the console');

            // Verificar sesi√≥n actual
            if (token) {
                fetch(`/api/session?token=${token}`)
                    .then(response => {
                        console.log('Session verification response status:', response.status);
                        return response.json();
                    })
                    .then(data => {
                        console.log('Session verification data:', data);
                    })
                    .catch(error => {
                        console.error('Session verification error:', error);
                    });
            }

            // Restaurar funci√≥n original despu√©s de 30 segundos
            setTimeout(() => {
                window.showNotification = originalShowNotification;
                console.log('üîÑ Notification interception restored');
            }, 30000);
        }

        // Funci√≥n para verificar todas las llamadas fetch que incluyen token
        function debugSessionRequests() {
            console.log('üîç === DEBUGGING SESSION REQUESTS ===');

            const originalFetch = window.fetch;
            window.fetch = function(url, options) {
                // Verificar si la llamada requiere sesi√≥n
                const requiresSession = url.includes('/api/') &&
                    !url.includes('/api/session?') &&
                    !url.includes('/api/login');

                if (requiresSession && !token) {
                    console.error('‚ùå INTENTANDO HACER LLAMADA API SIN SESI√ìN:', url);
                    showNotification('Sesi√≥n no iniciada. Redirigiendo al login...', 'error');
                    setTimeout(() => {
                        localStorage.removeItem('token');
                        token = null;
                        showLoginScreen();
                    }, 1000);
                    return Promise.reject(new Error('No session available'));
                }

                if (url.includes('token') || (options && options.body && options.body.includes('token'))) {
                    console.log('üì° SESSION REQUEST:', { url, method: options?.method });
                }

                return originalFetch.apply(this, arguments)
                    .then(response => {
                        if (url.includes('token') || (options && options.body && options.body.includes('token'))) {
                            console.log('üì° SESSION RESPONSE:', {
                                url,
                                status: response.status,
                                ok: response.ok
                            });

                            if (response.status === 401 || response.status === 403) {
                                console.error('‚ùå AUTHENTICATION ERROR DETECTED!');
                                console.trace('Call stack:');
                            }
                        }

                        // Manejar errores de sesi√≥n en tiempo real
                        if (response.status === 401 || response.status === 403) {
                            console.error(`üö® ERROR DE SESI√ìN (${response.status}) en:`, url);
                            showNotification('Sesi√≥n expirada o inv√°lida. Redirigiendo al login...', 'error');
                            setTimeout(() => {
                                localStorage.removeItem('token');
                                token = null;
                                showLoginScreen();
                            }, 2000);
                        }

                        return response;
                    }).catch(error => {
                        console.error('‚ùå ERROR EN FETCH:', error);
                        // Si es un error de red y tenemos token, intentar reconectar
                        if (!navigator.onLine && token) {
                            showNotification('Error de conexi√≥n. Verificando sesi√≥n...', 'error');
                            setTimeout(() => verifySession(token), 3000);
                        }
                        throw error;
                    });
            };

            console.log('‚úÖ Session request interception active');

            // Restaurar despu√©s de 30 segundos
            setTimeout(() => {
                window.fetch = originalFetch;
                console.log('üîÑ Fetch interception restored');
            }, 30000);
        }

        // Funci√≥n de ayuda para debugging de sesi√≥n
        function helpSessionDebugging() {
            console.log('üö® === HELP: SESSION DEBUGGING ===');
            console.log('');
            console.log('üìù ¬øAparece "no hay sesi√≥n activa" cada rato?');
            console.log('');
            console.log('üîß Pasos para diagnosticar:');
            console.log('1. Ejecuta: debugSessionMessage()');
            console.log('2. Ejecuta: debugSessionRequests()');
            console.log('3. Espera a que aparezca el mensaje');
            console.log('4. Revisa la consola para ver de d√≥nde viene');
            console.log('');
            console.log('üí° Posibles causas:');
            console.log('- El token expira en el servidor');
            console.log('- Problema de red que interrumpe las peticiones');
            console.log('- El backend est√° reiniciando o perdiendo sesiones');
            console.log('- Conflicto entre m√∫ltiples pesta√±as');
            console.log('');
            console.log('üõ†Ô∏è Soluciones posibles:');
            console.log('- emergencySessionSilence()    ‚Üê Silenciar mensajes 30 min');
            console.log('- extendSession()              ‚Üê Extender sesi√≥n manual');
            console.log('- Hacer refresh de la p√°gina (F5)');
            console.log('- Cerrar otras pesta√±as de la aplicaci√≥n');
            console.log('- Verificar la conexi√≥n de red');
            console.log('- Contactar al administrador del servidor');
        }

        // Exponer funciones de debugging de sesi√≥n
        window.debugSessionMessage = debugSessionMessage;
        window.debugSessionRequests = debugSessionRequests;
        window.helpSessionDebugging = helpSessionDebugging;

        // Funci√≥n para extender la sesi√≥n autom√°ticamente
        function extendSession() {
            if (token) {
                console.log('üîÑ Extending session...');
                fetch(`/api/session/extend?token=${token}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('‚úÖ Session extended successfully');
                            // Actualizar el token con el nuevo token recibido
                            if (data.token) {
                                token = data.token;
                                localStorage.setItem('chatbot_token', token);
                                console.log('üîë Token updated with extended session');
                            }
                            showNotification('Sesi√≥n extendida', 'success');
                        } else {
                            console.error('‚ùå Failed to extend session:', data.message);
                            showNotification('Error extendiendo sesi√≥n', 'error');
                        }
                    })
                    .catch(error => {
                        console.error('Error extending session:', error);
                        showNotification('Error de conexi√≥n al extender sesi√≥n', 'error');
                    });
            } else {
                console.error('No token available to extend');
            }
        }

        // Funci√≥n para verificar y renovar sesi√≥n autom√°ticamente
        function startSessionMaintenance() {
            window.sessionMaintenanceActive = true;
            console.log('üõ†Ô∏è Starting automatic session maintenance...');

            // Verificar sesi√≥n cada 5 minutos
            setInterval(() => {
                if (token) {
                    fetch(`/api/session?token=${token}`)
                        .then(response => {
                            if (response.status === 401 || response.status === 403) {
                                console.error('‚ùå Session expired - redirecting to login');
                                showNotification('Sesi√≥n expirada - redirigiendo al login', 'error');
                                setTimeout(() => {
                                    localStorage.removeItem('token');
                                    showLoginScreen();
                                }, 2000);
                                return;
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data && !data.success) {
                                console.warn('‚ö†Ô∏è Session validation failed:', data.message);
                                // Intentar extender la sesi√≥n
                                extendSession();
                            } else if (data && data.success) {
                                console.log('‚úÖ Session validated successfully');
                            }
                        })
                        .catch(error => {
                            console.error('Error validating session:', error);
                            // No mostrar error al usuario para evitar spam
                        });
                }
            }, 5 * 60 * 1000); // 5 minutos

            // Extender sesi√≥n cada 10 minutos si est√° activa
            setInterval(() => {
                if (token && document.getElementById('main-container').style.display !== 'none') {
                    extendSession();
                }
            }, 10 * 60 * 1000); // 10 minutos

            console.log('‚úÖ Session maintenance started');
            console.log('‚è±Ô∏è  Session will be validated every 5 minutes');
            console.log('üîÑ Session will be extended every 10 minutes');
        }

        // Iniciar mantenimiento de sesi√≥n al cargar la aplicaci√≥n
        function initializeSessionMaintenance() {
            if (token) {
                startSessionMaintenance();
            }
        }

        // Exponer funciones de mantenimiento de sesi√≥n
        window.extendSession = extendSession;
        window.startSessionMaintenance = startSessionMaintenance;
        window.initializeSessionMaintenance = initializeSessionMaintenance;

        // Funci√≥n de ayuda completa para el problema de sesi√≥n
        function helpSessionProblem() {
            console.log('üö® === SOLUCI√ìN COMPLETA: PROBLEMA DE SESI√ìN ===');
            console.log('');
            console.log('üìù Problema: "no hay sesi√≥n activa" aparece cada rato');
            console.log('');
            console.log('üîç PASO 1: Diagnosticar el problema');
            console.log('Ejecuta estos comandos en orden:');
            console.log('');
            console.log('1. helpSessionDebugging()     ‚Üê Informaci√≥n general');
            console.log('2. debugSessionMessage()      ‚Üê Interceptar mensajes');
            console.log('3. debugSessionRequests()     ‚Üê Ver peticiones HTTP');
            console.log('');
            console.log('‚è±Ô∏è  Espera 30 segundos despu√©s de ejecutar los comandos 2 y 3');
            console.log('   para que se activen y luego reproduce el problema.');
            console.log('');
            console.log('üõ†Ô∏è PASO 2: Soluciones inmediatas');
            console.log('');
            console.log('A) Si es problema de expiraci√≥n:');
            console.log('   - extendSession()              ‚Üê Extender sesi√≥n manual');
            console.log('   - startSessionMaintenance()    ‚Üê Iniciar mantenimiento autom√°tico');
            console.log('');
            console.log('B) Si es problema de red:');
            console.log('   - Verifica tu conexi√≥n a internet');
            console.log('   - Recarga la p√°gina (F5)');
            console.log('   - Cierra otras pesta√±as de la aplicaci√≥n');
            console.log('');
            console.log('C) Si es problema del servidor:');
            console.log('   - Contacta al administrador del servidor');
            console.log('   - El mantenimiento autom√°tico intentar√° renovar la sesi√≥n');
            console.log('');
            console.log('‚ö° FUNCIONES DE EMERGENCIA:');
            console.log('- emergencySessionSilence()  ‚Üê Silenciar mensajes 30 min');
            console.log('- forceConnectionCheck()     ‚Üê Verificar conexi√≥n forzadamente');
            console.log('- diagnoseQRModal()          ‚Üê Diagn√≥stico completo del sistema');
            console.log('');
            console.log('üìä ESTADO ACTUAL DEL SISTEMA:');
            console.log('- Token:', token);
            console.log('- Usuario actual:', currentUser ? currentUser.username : 'null');
            console.log('- Mantenimiento activo:', window.sessionMaintenanceActive || false);
            console.log('');
            console.log('üí° RECUERDA: El sistema ahora tiene mantenimiento autom√°tico');
            console.log('   que verifica la sesi√≥n cada 5 minutos y la extiende cada 10 minutos.');
        }

        // Exponer funci√≥n de ayuda completa
        window.helpSessionProblem = helpSessionProblem;

        // Funciones para el contador de sesi√≥n
        function getSessionStatus() {
            const elapsed = Date.now() - lastActivityTime;
            const remaining = sessionDuration - elapsed;
            const remainingMinutes = Math.floor(remaining / (60 * 1000));
            const remainingSeconds = Math.floor((remaining % (60 * 1000)) / 1000);

            console.log('=== SESSION STATUS ===');
            console.log('Session Duration:', Math.floor(sessionDuration / (60 * 1000)), 'minutes');
            console.log('Time Elapsed:', Math.floor(elapsed / (60 * 1000)), 'minutes');
            console.log('Time Remaining:', remainingMinutes, 'minutes', remainingSeconds, 'seconds');
            console.log('Last Activity:', new Date(lastActivityTime).toLocaleTimeString());
            console.log('Session Timer Active:', !!sessionTimer);
            console.log('Warning Shown:', sessionWarningShown);
            console.log('Critical Shown:', sessionCriticalShown);

            return {
                duration: sessionDuration,
                elapsed: elapsed,
                remaining: remaining,
                lastActivity: lastActivityTime,
                timerActive: !!sessionTimer,
                warningShown: sessionWarningShown,
                criticalShown: sessionCriticalShown
            };
        }

        function setSessionDuration(minutes) {
            console.log(`Setting session duration to ${minutes} minutes`);
            sessionDuration = minutes * 60 * 1000;
            lastActivityTime = Date.now(); // Reset timer
            sessionWarningShown = false;
            sessionCriticalShown = false;

            // Actualizar el contador inmediatamente
            const sessionCounter = document.getElementById('session-counter');
            if (sessionCounter) {
                sessionCounter.classList.remove('warning', 'critical');
            }

            showNotification(`Duraci√≥n de sesi√≥n cambiada a ${minutes} minutos`, 'info');
        }

        // Exponer funciones del contador de sesi√≥n
        window.getSessionStatus = getSessionStatus;
        window.setSessionDuration = setSessionDuration;
        window.extendSessionManually = extendSessionManually;

        // Funci√≥n de ayuda para el contador de sesi√≥n
        function helpSessionCounter() {
            console.log('‚è±Ô∏è === AYUDA: CONTADOR DE SESI√ìN ===');
            console.log('');
            console.log('üìç ¬øD√≥nde est√° el contador?');
            console.log('   - En el header, al lado del bot√≥n de informaci√≥n del usuario');
            console.log('   - Muestra el tiempo restante en formato MM:SS');
            console.log('   - Tiene un √≠cono de reloj animado');
            console.log('');
            console.log('‚ö° ¬øQu√© hace?');
            console.log('   - Cuenta regresiva desde 15 minutos');
            console.log('   - Se reinicia con cualquier actividad del usuario');
            console.log('   - Cambia de color cuando quedan pocos minutos');
            console.log('   - Redirige al login cuando llega a 00:00');
            console.log('');
            console.log('üé® Colores del contador:');
            console.log('   üîµ Azul: Tiempo normal (> 5 min)');
            console.log('   üü° Amarillo: Advertencia (‚â§ 5 min)');
            console.log('   üî¥ Rojo: Cr√≠tico (‚â§ 2 min)');
            console.log('');
            console.log('üñ±Ô∏è Interacci√≥n:');
            console.log('   - Click: Extiende la sesi√≥n manualmente');
            console.log('   - Hover: Muestra "Click para extender la sesi√≥n"');
            console.log('');
            console.log('üõ†Ô∏è Comandos √∫tiles:');
            console.log('   - getSessionStatus(): Ver estado actual');
            console.log('   - setSessionDuration(20): Cambiar a 20 minutos');
            console.log('   - extendSessionManually(): Extender sesi√≥n');
            console.log('');
            console.log('‚öôÔ∏è Configuraci√≥n por defecto:');
            console.log('   - Duraci√≥n: 15 minutos');
            console.log('   - Advertencia: 5 minutos restantes');
            console.log('   - Cr√≠tico: 2 minutos restantes');
            console.log('');
            console.log('üí° Tip: El contador se reinicia autom√°ticamente con cualquier actividad');
        }

        // Exponer funci√≥n de ayuda del contador
        window.helpSessionCounter = helpSessionCounter;

        // Funci√≥n para verificar que el sistema est√© funcionando correctamente
        function verifySystemStatus() {
            console.log('üîç === VERIFICACI√ìN DEL SISTEMA ===');
            console.log('');

            // Verificar elementos principales
            const elements = {
                'QR Modal': document.getElementById('qr-modal'),
                'Scan QR Button': document.getElementById('scan-qr-btn'),
                'Session Counter': document.getElementById('session-counter'),
                'Messages Area': document.getElementById('messages-area'),
                'Main Container': document.getElementById('main-container')
            };

            console.log('üìä Elementos del DOM:');
            Object.entries(elements).forEach(([name, element]) => {
                const exists = !!element;
                const visible = element ? !element.classList.contains('hidden') : false;
                console.log(`   ${exists ? '‚úÖ' : '‚ùå'} ${name}: ${exists ? (visible ? 'Visible' : 'Hidden') : 'No encontrado'}`);
            });

            console.log('');
            console.log('‚öôÔ∏è Estado de la aplicaci√≥n:');
            console.log(`   - Token: ${token || 'No definido'}`);
            console.log(`   - Usuario actual: ${currentUser ? currentUser.username : 'No definido'}`);
            console.log(`   - Chat actual: ${currentChatId || 'Ninguno'}`);
            console.log(`   - WhatsApp conectado: ${isConnected}`);
            console.log(`   - Contador de sesi√≥n activo: ${!!sessionTimer}`);

            console.log('');
            console.log('üõ†Ô∏è Funciones disponibles:');
            console.log('   - helpSessionCounter(): Ayuda del contador de sesi√≥n');
            console.log('   - getSessionStatus(): Estado actual de la sesi√≥n');
            console.log('   - debugQRModal(): Debug del modal QR');
            console.log('   - diagnoseQRModal(): Diagn√≥stico completo');

            return {
                elements: Object.fromEntries(Object.entries(elements).map(([k, v]) => [k, !!v])),
                session: {
                    id: token,
                    user: currentUser?.username,
                    connected: isConnected,
                    counterActive: !!sessionTimer
                }
            };
        }

        // Exponer funci√≥n de verificaci√≥n del sistema
        window.verifySystemStatus = verifySystemStatus;

        // Funci√≥n de ayuda para verificar que el sistema est√° funcionando correctamente
        function helpSystemStatus() {
            console.log('üîç === ESTADO DEL SISTEMA ===');
            console.log('');
            console.log('‚úÖ Sistema con preservaci√≥n completa de audio:');
            console.log('   - Actualizaci√≥n de chat: Simple y directa');
            console.log('   - Reproducci√≥n de audio: NO se interrumpe, se reanuda autom√°ticamente');
            console.log('   - Preservaci√≥n de audio: ‚úÖ ACTIVA con reanudaci√≥n autom√°tica');
            console.log('   - Manejo de errores de audio: Detecta y muestra mensajes informativos');
            console.log('   - Scroll: Autom√°tico al final');
            console.log('   - Sin polling inteligente');
            console.log('');
            console.log('‚úÖ Funcionalidades activas:');
            console.log('   - Contador de sesi√≥n: ‚úÖ Activo');
            console.log('   - Bot√≥n escanear QR: ‚úÖ Activo');
            console.log('   - Modal QR: ‚úÖ Funcional');
            console.log('   - Actualizaci√≥n de mensajes: ‚úÖ Simple');
            console.log('   - üéµ Preservaci√≥n de audio: ‚úÖ ACTIVA');
            console.log('   - üéµ Manejo de errores de audio: ‚úÖ Activo');
            console.log('');
            console.log('üõ†Ô∏è Comandos de verificaci√≥n:');
            console.log('   - verifySystemStatus(): Verificar elementos del DOM');
            console.log('   - helpSessionCounter(): Ayuda del contador');
            console.log('   - getSessionStatus(): Estado de la sesi√≥n');
            console.log('   - helpAudioProblem(): Ayuda del sistema de audio');
            console.log('   - debugAudioElements(): Ver estado de audios');
            console.log('   - quickAudioCheck(): Verificaci√≥n r√°pida de audio');
            console.log('   - testAudioPreservation(): Probar preservaci√≥n de audio');
            console.log('');
            console.log('üéØ Estado actual:');
            const status = verifySystemStatus();
            console.log('   - Elementos del DOM:', Object.values(status.elements).filter(Boolean).length + '/' + Object.keys(status.elements).length, 'OK');
            console.log('   - Sesi√≥n activa:', status.session.id ? '‚úÖ' : '‚ùå');
            console.log('   - Contador activo:', status.session.counterActive ? '‚úÖ' : '‚ùå');
        }

        // Exponer funci√≥n de ayuda del sistema
        window.helpSystemStatus = helpSystemStatus;

        // Funci√≥n para probar la preservaci√≥n de audio durante actualizaciones
        function testAudioPreservation() {
            console.log('üéµ === TESTING AUDIO PRESERVATION ===');

            // Simular que hay un audio reproduci√©ndose
            const audioElements = document.querySelectorAll('audio');
            if (audioElements.length === 0) {
                console.log('‚ÑπÔ∏è No se encontraron elementos de audio para probar');
                console.log('üí° Reproduce un audio en el chat y luego ejecuta esta funci√≥n');
                return;
            }

            console.log(`üéß Encontrados ${audioElements.length} elementos de audio`);

            // Guardar estados actuales
            console.log('1. Guardando estados de audio...');
            const savedStates = saveAudioStates();
            console.log(`   Estados guardados: ${savedStates.size}`);

            // Simular una actualizaci√≥n del chat
            setTimeout(() => {
                console.log('2. Simulando actualizaci√≥n del chat...');
                // Recrear el contenido del messagesArea
                const messagesArea = document.getElementById('messages-area');
                const currentContent = messagesArea.innerHTML;
                messagesArea.innerHTML = currentContent; // Recrear mismo contenido

                // Restaurar estados
                setTimeout(() => {
                    console.log('3. Restaurando estados de audio...');
                    restoreAudioStates(savedStates);

                    setTimeout(() => {
                        console.log('‚úÖ Test de preservaci√≥n completado');
                        console.log('üéµ Los audios deber√≠an mantener su posici√≥n sin interrumpirse');
                    }, 200);
                }, 100);
            }, 500);
        }

        // Funci√≥n para ver el estado actual de todos los audios
        function debugAudioElements() {
            console.log('üîä === AUDIO ELEMENTS DEBUG ===');

            const audioElements = document.querySelectorAll('audio');
            console.log(`Total audio elements: ${audioElements.length}`);

            audioElements.forEach((audio, index) => {
                const messageElement = audio.closest('.message');
                const messageId = messageElement?.dataset.messageId || `audio-${index}`;

                console.log(`üéµ Audio ${index + 1}:`);
                console.log(`   ID: ${messageId}`);
                console.log(`   Src: ${audio.src || 'No source'}`);
                console.log(`   Current time: ${audio.currentTime.toFixed(2)}s`);
                console.log(`   Duration: ${audio.duration.toFixed(2)}s`);
                console.log(`   Is playing: ${!audio.paused}`);
                console.log(`   Volume: ${audio.volume}`);
                console.log(`   Muted: ${audio.muted}`);
                console.log(`   Ready state: ${audio.readyState}`);
                console.log('');
            });

            if (audioElements.length === 0) {
                console.log('‚ÑπÔ∏è No hay elementos de audio en el chat actual');
            }
        }

        // Funci√≥n de ayuda espec√≠fica para el problema de audio
        function helpAudioProblem() {
            console.log('üéµ === AYUDA: PROBLEMA DE AUDIO ===');
            console.log('');
            console.log('üìù Problema: Los audios se cortan durante actualizaciones del chat');
            console.log('');
            console.log('‚úÖ Estado actual:');
            console.log('   - Sistema de preservaci√≥n de audio: ‚úÖ ACTIVO');
            console.log('   - Los audios YA NO se interrumpen durante actualizaciones del chat');
            console.log('   - Reanudaci√≥n autom√°tica: ‚úÖ ACTIVA para audios que estaban reproduci√©ndose');
            console.log('   - Manejo de errores de audio: ‚úÖ ACTIVO');
            console.log('   - Mensajes informativos para formatos no soportados');
            console.log('');
            console.log('üõ†Ô∏è Funciones de debugging:');
            console.log('   - debugAudioElements(): Ver estado de todos los audios');
            console.log('   - quickAudioCheck(): Verificaci√≥n r√°pida');
            console.log('   - testAudioErrors(): Probar manejo de errores');
            console.log('   - checkAudioFormatSupport(): Verificar formatos soportados');
            console.log('');
            console.log('‚öôÔ∏è Comportamiento actual:');
            console.log('   1. üíæ Guardar estado de audios que est√°n reproduci√©ndose');
            console.log('   2. üîÑ Actualizar contenido del chat');
            console.log('   3. ‚úÖ Restaurar posici√≥n y configuraci√≥n de audios');
            console.log('   4. ‚ñ∂Ô∏è Los audios que estaban reproduci√©ndose se reanudan AUTOM√ÅTICAMENTE');
            console.log('   5. ‚ö†Ô∏è Si hay error, se muestra mensaje informativo');
            console.log('');
            console.log('üí° Situaci√≥n actual:');
            console.log('   - Los audios YA NO se interrumpen durante actualizaciones');
            console.log('   - Se preserva la posici√≥n exacta de reproducci√≥n');
            console.log('   - Se mantiene volumen, velocidad y configuraci√≥n');
            console.log('   - Los audios que estaban reproduci√©ndose CONTINUAN reproduci√©ndose');
            console.log('   - Sin intervenci√≥n manual del usuario');
            console.log('');
            console.log('üéØ Mejoras implementadas:');
            console.log('   - Sistema completo de preservaci√≥n de audio');
            console.log('   - Reanudaci√≥n autom√°tica de reproducci√≥n');
            console.log('   - Mensajes informativos para formatos no soportados');
            console.log('   - Detecci√≥n autom√°tica de errores de audio');
            console.log('   - Informaci√≥n detallada sobre el tipo de error');
            console.log('   - Recomendaciones para navegadores modernos');
            console.log('   - IDs √∫nicos para mejor tracking de elementos');
        }

        // Exponer funciones de debugging de audio
        window.debugAudioElements = debugAudioElements;
        window.helpAudioProblem = helpAudioProblem;

        // Funci√≥n r√°pida para verificar que el audio funciona correctamente
        function quickAudioCheck() {
            console.log('üéµ === QUICK AUDIO CHECK ===');

            const audioElements = document.querySelectorAll('audio');
            const hasPlayingAudio = Array.from(audioElements).some(audio => !audio.paused);

            console.log(`üìä Audio elements found: ${audioElements.length}`);
            console.log(`‚ñ∂Ô∏è  Audio currently playing: ${hasPlayingAudio ? 'YES' : 'NO'}`);

            if (hasPlayingAudio) {
                console.log('‚úÖ Audio is playing and will continue playing during chat updates');
                console.log('üí° Test: Send a message while audio is playing to verify automatic continuation');
            } else {
                console.log('‚ÑπÔ∏è No audio is currently playing');
                console.log('üí° Test: Play an audio and then send a message to verify automatic continuation');
            }

            // Mostrar informaci√≥n adicional
            if (audioElements.length > 0) {
                console.log('üîß Audio optimization applied:');
                console.log('   - preload="none" to prevent auto-downloads');
                console.log('   - controls added for better UX');
                console.log('   - ‚úÖ STATE PRESERVATION during chat updates');
                console.log('   - üéµ Audio playback will continue automatically');
                console.log('   - ‚ñ∂Ô∏è No user interaction required');
            }

            return {
                audioCount: audioElements.length,
                hasPlayingAudio: hasPlayingAudio,
                optimizationActive: audioElements.length > 0
            };
        }



        // Funci√≥n para probar errores de audio espec√≠ficamente
        function testAudioErrors() {
            console.log('üß™ === TESTING AUDIO ERRORS ===');

            const audioElements = document.querySelectorAll('audio');
            console.log(`üéµ Found ${audioElements.length} audio elements`);

            if (audioElements.length === 0) {
                console.log('‚ÑπÔ∏è No audio elements found. Try sending an audio message first.');
                return;
            }

            // Forzar un error en el primer elemento de audio para probar
            const testAudio = audioElements[0];
            console.log('üîß Testing audio error handling...');

            // Crear un elemento de audio con una URL inv√°lida para forzar error
            const errorAudio = document.createElement('audio');
            errorAudio.src = 'invalid-audio-url.ogg';
            errorAudio.controls = true;
            errorAudio.preload = 'none';

            // Agregar el contenedor con mensaje de error
            const container = document.createElement('div');
            container.className = 'audio-container';
            container.innerHTML = `
                ${errorAudio.outerHTML}
                <div class="audio-error-message" style="
                    color: #666;
                    font-size: 12px;
                    margin-top: 8px;
                    padding: 8px;
                    background: #f8f9fa;
                    border-radius: 4px;
                    border: 1px solid #dee2e6;
                    display: none;
                ">
                    <strong>‚ö†Ô∏è Tu navegador no soporta el elemento de audio.</strong><br>
                    <span style="font-size: 11px;">Formato: audio/ogg - Intenta usar un navegador actualizado como Chrome, Firefox o Edge.</span>
                </div>
            `;

            // Agregar al DOM para probar
            testAudio.parentElement.appendChild(container);

            // Forzar el error
            errorAudio.addEventListener('error', function() {
                console.log('‚úÖ Audio error handling triggered successfully!');
                console.log('üéØ Error message should be visible now');
            });

            console.log('üîÑ Test completed - check if error message appears');
        }

        // Funci√≥n para verificar soporte de formatos de audio
        function checkAudioFormatSupport() {
            console.log('üîç === AUDIO FORMAT SUPPORT CHECK ===');

            const audio = document.createElement('audio');
            const formats = [
                { format: 'audio/ogg', ext: 'ogg', name: 'OGG' },
                { format: 'audio/mp3', ext: 'mp3', name: 'MP3' },
                { format: 'audio/wav', ext: 'wav', name: 'WAV' },
                { format: 'audio/mpeg', ext: 'mp3', name: 'MPEG' },
                { format: 'audio/ogg; codecs="vorbis"', ext: 'ogg', name: 'OGG Vorbis' }
            ];

            formats.forEach(format => {
                const support = audio.canPlayType(format.format);
                const supportText = support === 'probably' ? '‚úÖ Soportado' :
                                   support === 'maybe' ? '‚ö†Ô∏è Posiblemente soportado' :
                                   '‚ùå No soportado';
                console.log(`${supportText} - ${format.name} (${format.format})`);
            });

            console.log('');
            console.log('üí° Recomendaciones:');
            console.log('   - Si OGG no funciona, considera usar MP3 o WAV');
            console.log('   - Usa navegadores modernos para mejor soporte');
        }

        // Funci√≥n para probar espec√≠ficamente la preservaci√≥n de audio
        function testAudioPreservation() {
            console.log('üß™ === TESTING AUDIO PRESERVATION ===');

            const audioElements = document.querySelectorAll('audio');
            const playingAudios = Array.from(audioElements).filter(audio => !audio.paused);

            if (playingAudios.length === 0) {
                console.log('‚ÑπÔ∏è No hay audios reproduci√©ndose actualmente');
                console.log('üí° Reproduce un audio primero y luego ejecuta esta funci√≥n');
                return;
            }

            console.log(`üéµ Audios reproduci√©ndose: ${playingAudios.length}`);
            console.log('üîÑ Simulando actualizaci√≥n del chat...');

            // Guardar estados actuales
            const savedStates = saveAudioStates();
            console.log(`üíæ Estados guardados: ${savedStates.size}`);

            // Simular recreaci√≥n del contenido
            const messagesArea = document.getElementById('messages-area');
            const currentContent = messagesArea.innerHTML;

            setTimeout(() => {
                // Recrear contenido (esto es lo que har√≠a displayMessages)
                messagesArea.innerHTML = currentContent;

                setTimeout(() => {
                    // Restaurar estados
                    restoreAudioStates(savedStates);

                    setTimeout(() => {
                        console.log('‚úÖ Test completado');
                        console.log('üéµ Los audios deber√≠an mantener su posici√≥n y continuar reproduci√©ndose');
                        console.log('üí° Los audios que estaban reproduci√©ndose deber√≠an continuar autom√°ticamente');

                        // Verificar que los audios se restauraron correctamente
                        const restoredAudios = document.querySelectorAll('audio');
                        restoredAudios.forEach((audio, index) => {
                            if (audio.currentTime > 0) {
                                const status = !audio.paused ? 'reproduci√©ndose' : 'pausado';
                                console.log(`‚úÖ Audio ${index + 1}: Posici√≥n restaurada a ${audio.currentTime.toFixed(2)}s - ${status}`);
                            }
                        });
                    }, 300);
                }, 150);
            }, 500);
        }

        // Exponer funci√≥n de verificaci√≥n r√°pida
        window.quickAudioCheck = quickAudioCheck;
        window.testAudioErrors = testAudioErrors;
        window.checkAudioFormatSupport = checkAudioFormatSupport;
        window.testAudioPreservation = testAudioPreservation;

        // Funci√≥n de emergencia para silenciar mensajes problem√°ticos temporalmente
        function emergencySessionSilence() {
            console.log('üö® === EMERGENCY SESSION SILENCE ACTIVATED ===');
            console.log('‚è∞ This will temporarily silence session-related notifications for 30 minutes');

            // Silenciar showNotification temporalmente
            const originalShowNotification = window.showNotification;
            window.showNotification = function(message, type) {
                // Solo permitir mensajes cr√≠ticos, bloquear los de sesi√≥n
                if (message.toLowerCase().includes('sesi√≥n') ||
                    message.toLowerCase().includes('session') ||
                    message.toLowerCase().includes('expirada') ||
                    message.toLowerCase().includes('expired') ||
                    message.toLowerCase().includes('activa') ||
                    message.toLowerCase().includes('active')) {

                    console.log('üîá Session notification blocked:', message);
                    return; // No mostrar la notificaci√≥n
                }

                return originalShowNotification.apply(this, arguments);
            };

            // Intentar extender la sesi√≥n inmediatamente
            if (token) {
                extendSession();
            }

            // Restaurar notificaciones despu√©s de 30 minutos
            setTimeout(() => {
                window.showNotification = originalShowNotification;
                console.log('üîÑ Emergency silence ended - notifications restored');
                showNotification('Silencio de emergencia terminado', 'info');
            }, 30 * 60 * 1000); // 30 minutos

            console.log('‚úÖ Emergency session silence activated');
            console.log('üí° Use helpSessionProblem() for permanent solutions');
        }

        // Exponer funci√≥n de emergencia
        window.emergencySessionSilence = emergencySessionSilence;

        // Funci√≥n que muestra todas las herramientas disponibles
        function showAllSessionTools() {
            console.log('üõ†Ô∏è === TODAS LAS HERRAMIENTAS DE SESI√ìN ===');
            console.log('');
            console.log('üîç DIAGN√ìSTICO:');
            console.log('  helpSessionProblem()       ‚Üê Gu√≠a completa de soluci√≥n');
            console.log('  debugSessionMessage()      ‚Üê Interceptar mensajes de sesi√≥n');
            console.log('  debugSessionRequests()     ‚Üê Ver peticiones HTTP');
            console.log('');
            console.log('üõ†Ô∏è MANTENIMIENTO:');
            console.log('  extendSession()            ‚Üê Extender sesi√≥n manualmente');
            console.log('  startSessionMaintenance()  ‚Üê Iniciar mantenimiento autom√°tico');
            console.log('');
            console.log('üö® EMERGENCIA:');
            console.log('  emergencySessionSilence()  ‚Üê Silenciar mensajes 30 min');
            console.log('');
            console.log('üîß GENERAL:');
            console.log('  forceConnectionCheck()     ‚Üê Verificar conexi√≥n forzadamente');
            console.log('  diagnoseQRModal()          ‚Üê Diagn√≥stico del sistema QR');
            console.log('');
            console.log('üí° CONSEJO: Comienza con helpSessionProblem() para una soluci√≥n paso a paso');
        }

        // Exponer funci√≥n que muestra todas las herramientas
        window.showAllSessionTools = showAllSessionTools;

        async function refreshQR() {
            try {
                // Actualizar indicador de estado a "generando"
                updateQRStatusIndicator('connecting', '<i class="fas fa-spinner fa-spin"></i> Generando nuevo c√≥digo QR...');

                await fetch('/api/qr/refresh', { method: 'POST' });
                showNotification('Regenerando c√≥digo QR...', 'info');

                // Verificar si WhatsApp est√° conectado antes de mostrar el QR
                setTimeout(async () => {
                    try {
                        const response = await fetch('/api/stats');
                        const data = await response.json();
                        const isWhatsAppReady = data.whatsappListo || data.connected || data.ready;

                        if (!isWhatsAppReady) {
                            // Actualizar indicador a "esperando conexi√≥n"
                            updateQRStatusIndicator('connecting', '<i class="fas fa-spinner fa-spin"></i> Esperando conexi√≥n de WhatsApp...');
                            showQRModal();
                        } else {
                            updateQRStatusIndicator('connected', '<i class="fas fa-check-circle"></i> WhatsApp ya est√° conectado');
                            showNotification('WhatsApp ya est√° conectado - QR no necesario', 'success');
                            setTimeout(() => hideQRModalManually(), 2000);
                        }
            } catch (error) {
                        console.error('Error checking connection in refreshQR:', error);
                        // En caso de error, mostrar QR como fallback
                        updateQRStatusIndicator('error', '<i class="fas fa-exclamation-triangle"></i> Error generando QR');
                        showQRModal();
                    }
                }, 3000);
            } catch (error) {
                updateQRStatusIndicator('error', '<i class="fas fa-exclamation-triangle"></i> Error regenerando QR');
                showNotification('Error regenerando QR', 'error');
            }
        }

        function setupFileHandling() {
            const attachBtn = document.getElementById('attach-btn');
            const fileInput = document.getElementById('file-input');
            const messageInputArea = document.getElementById('message-input-area');
            const dragOverlay = document.getElementById('drag-overlay');
            const clearFilesBtn = document.getElementById('clear-files-btn');

            if (attachBtn && fileInput) {
                attachBtn.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => {
                    handleFiles(Array.from(e.target.files));
                });
            }

            if (messageInputArea) {
                messageInputArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    messageInputArea.classList.add('drag-over');
                    if (dragOverlay) dragOverlay.style.display = 'flex';
                });

                messageInputArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!messageInputArea.contains(e.relatedTarget)) {
                        messageInputArea.classList.remove('drag-over');
                        if (dragOverlay) dragOverlay.style.display = 'none';
                    }
                });

                messageInputArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    messageInputArea.classList.remove('drag-over');
                    if (dragOverlay) dragOverlay.style.display = 'none';

                    const files = Array.from(e.dataTransfer.files);
                    handleFiles(files);
                });
            }

            if (clearFilesBtn) {
                clearFilesBtn.addEventListener('click', clearFiles);
            }
        }

        function handleFiles(files) {
            const validFiles = files.filter(file => {
                if (file.size > 50 * 1024 * 1024) {
                    showNotification(`El archivo "${file.name}" es demasiado grande (mÔøΩximo 50MB)`, 'error');
                    return false;
                }
                return true;
            });

            selectedFiles = [...selectedFiles, ...validFiles];
            updateFilePreview();
            
            const previewArea = document.getElementById('file-preview-area');
            if (previewArea && selectedFiles.length > 0) {
                previewArea.style.display = 'block';
            }
        }

        function updateFilePreview() {
            const previewList = document.getElementById('file-preview-list');
            if (!previewList) return;

            previewList.innerHTML = '';

            selectedFiles.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'file-preview-item';
                
                if (file.type.startsWith('image/')) {
                    item.classList.add('image');
                    const img = document.createElement('img');
                    img.className = 'file-preview-image';
                    img.src = URL.createObjectURL(file);
                    item.appendChild(img);
                } else {
                    const icon = document.createElement('div');
                    icon.className = 'file-preview-icon';
                    icon.innerHTML = getFileIcon(file.type);
                    item.appendChild(icon);
                }

                const info = document.createElement('div');
                info.className = 'file-preview-info';
                
                const name = document.createElement('div');
                name.className = 'file-preview-name';
                name.textContent = file.name;
                name.title = file.name;
                
                const size = document.createElement('div');
                size.className = 'file-preview-size';
                size.textContent = formatFileSize(file.size);
                
                info.appendChild(name);
                info.appendChild(size);
                item.appendChild(info);

                const removeBtn = document.createElement('button');
                removeBtn.className = 'file-preview-remove';
                removeBtn.innerHTML = 'ÔøΩ';
                removeBtn.onclick = () => removeFile(index);
                item.appendChild(removeBtn);

                previewList.appendChild(item);
            });
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            updateFilePreview();
            
            if (selectedFiles.length === 0) {
                const previewArea = document.getElementById('file-preview-area');
                if (previewArea) previewArea.style.display = 'none';
            }
        }

        function clearFiles() {
            selectedFiles = [];
            updateFilePreview();
            const previewArea = document.getElementById('file-preview-area');
            if (previewArea) previewArea.style.display = 'none';
        }

        function getFileIcon(mimeType) {
            if (mimeType.startsWith('image/')) return '<i class="fas fa-image"></i>';
            if (mimeType.startsWith('video/')) return '<i class="fas fa-video"></i>';
            if (mimeType.startsWith('audio/')) return '<i class="fas fa-music"></i>';
            if (mimeType.includes('pdf')) return '<i class="fas fa-file-pdf"></i>';
            if (mimeType.includes('word') || mimeType.includes('document')) return '<i class="fas fa-file-word"></i>';
            if (mimeType.includes('zip') || mimeType.includes('rar')) return '<i class="fas fa-file-archive"></i>';
            return '<i class="fas fa-file"></i>';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Variables para optimizar las actualizaciones de mensajes
        let lastMessagesHash = '';
        let messagePollingInterval = null;
        let pendingWebMessages = new Map(); // Cache de mensajes enviados desde web que a√∫n no est√°n en el servidor
        let userIsScrolling = false; // Detectar si el usuario est√° navegando
        let scrollTimeout = null;

        function startSmartMessagePolling() {
            if (messagePollingInterval) {
                clearInterval(messagePollingInterval);
            }

            // Auto-refresco cada 5 segundos cuando hay un chat abierto (reducido para mejor UX)
            messagePollingInterval = setInterval(() => {
                if (currentChatId && !userIsScrolling) {
                    // Refresco silencioso sin forzar para preservar scroll (solo si el usuario no est√° navegando)
                    loadMessagesSmart(currentChatId, false, true); // false = no forzar, true = silencioso
                }
            }, 5000); // Cada 5 segundos

            console.log('üîÑ [POLLING] Auto-refresco activado cada 5 segundos para chat abierto');
        }

        function stopSmartMessagePolling() {
            if (messagePollingInterval) {
                clearInterval(messagePollingInterval);
                messagePollingInterval = null;
                console.log('‚èπÔ∏è [POLLING] Auto-refresco detenido');
            }
        }

        // Configurar detecci√≥n de scroll para pausar actualizaciones durante navegaci√≥n
        function setupScrollDetection() {
            const messagesArea = document.getElementById('messages-area');
            if (!messagesArea) return;

            // Remover listeners anteriores si existen
            messagesArea.removeEventListener('scroll', handleScroll);
            messagesArea.removeEventListener('wheel', handleScroll);
            messagesArea.removeEventListener('touchstart', handleScroll);
            messagesArea.removeEventListener('touchmove', handleScroll);

            // Agregar listeners para detectar navegaci√≥n
            messagesArea.addEventListener('scroll', handleScroll, { passive: true });
            messagesArea.addEventListener('wheel', handleScroll, { passive: true });
            messagesArea.addEventListener('touchstart', handleScroll, { passive: true });
            messagesArea.addEventListener('touchmove', handleScroll, { passive: true });
        }

        function handleScroll() {
            userIsScrolling = true;

            // Limpiar timeout anterior
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }

            // Despu√©s de 3 segundos sin scroll, reanudar actualizaciones
            scrollTimeout = setTimeout(() => {
                userIsScrolling = false;
            }, 3000);
        }

        // Combinar mensajes del servidor con mensajes web pendientes
        function combineMessagesWithPending(serverMessages, chatId) {
            const pendingMessages = pendingWebMessages.get(chatId) || [];

            if (pendingMessages.length === 0) {
                return serverMessages;
            }

            // Crear una copia de los mensajes del servidor
            const combined = [...serverMessages];

            // Agregar mensajes pendientes que no est√©n ya en el servidor
            pendingMessages.forEach(pendingMsg => {
                const existsInServer = serverMessages.some(serverMsg =>
                    Math.abs(serverMsg.timestamp - pendingMsg.timestamp) < 5000 && // 5 segundos de tolerancia
                    serverMsg.body === pendingMsg.body &&
                    serverMsg.fromMe === pendingMsg.fromMe
                );

                if (!existsInServer) {
                    combined.push(pendingMsg);
                }
            });

            // Ordenar por timestamp
            return combined.sort((a, b) => a.timestamp - b.timestamp);
        }

        // Limpiar mensajes web que ya han sido sincronizados al servidor
        function cleanupSyncedWebMessages(serverMessages, chatId) {
            const pendingMessages = pendingWebMessages.get(chatId) || [];

            if (pendingMessages.length === 0) {
                return;
            }

            // Filtrar mensajes que ya no est√°n pendientes
            const stillPending = pendingMessages.filter(pendingMsg => {
                const existsInServer = serverMessages.some(serverMsg =>
                    Math.abs(serverMsg.timestamp - pendingMsg.timestamp) < 10000 && // 10 segundos de tolerancia
                    serverMsg.body === pendingMsg.body &&
                    serverMsg.fromMe === pendingMsg.fromMe
                );
                return !existsInServer;
            });

            // Actualizar el cache
            if (stillPending.length === 0) {
                pendingWebMessages.delete(chatId);
            } else {
                pendingWebMessages.set(chatId, stillPending);
            }

            console.log(`üßπ [CLEANUP] Chat ${chatId}: ${pendingMessages.length - stillPending.length} mensajes sincronizados, ${stillPending.length} a√∫n pendientes`);
        }

        // Funci√≥n inteligente para cargar mensajes solo cuando sea necesario
        async function loadMessagesSmart(chatId, forceReload = false, silent = false) {
            let loadingIndicator = null;

            try {
                if (!silent) {
                    console.log(`üîç Verificando mensajes para chat ${chatId}${forceReload ? ' (recarga forzada)' : ''}...`);
                }
                
                // Mostrar indicador de carga solo para recarga forzada y no silenciosa
                if (forceReload && !silent) {
                    loadingIndicator = showHistoryLoadingIndicator();
                }

                // *** SOLUCION: Usar endpoints espec√≠ficos para obtener historial completo ***
                let response;
                let url;
                
                if (forceReload) {
                    // Para recarga forzada, usar el endpoint de historial extendido
                    url = `/api/chats/${chatId}/history?includeAll=true&limit=100`;
                    if (!silent) console.log(`üîÑ [FORCE RELOAD] Usando endpoint de historial extendido: ${url}`);
                } else {
                    // Para actualizaciones peri√≥dicas, usar el endpoint est√°ndar
                    url = `/api/chats/${chatId}/messages`;
                    if (!silent) console.log(`üîÑ [PERIODIC UPDATE] Usando endpoint est√°ndar: ${url}`);
                }
                
                response = await fetch(url);
                let data;

                if (!response.ok) {
                    console.warn(`‚ö†Ô∏è Endpoint primario fall√≥ (${response.status}), intentando endpoint alternativo...`);
                    // Si el endpoint de historial falla, intentar el est√°ndar
                    const fallbackUrl = `/api/chats/${chatId}/messages`;
                    console.log(`üîÑ [FALLBACK] Intentando endpoint alternativo: ${fallbackUrl}`);
                    response = await fetch(fallbackUrl);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} en ambos endpoints`);
                    }
                    data = await response.json();
                } else {
                    data = await response.json();
                    if (!silent) console.log(`‚úÖ [API SUCCESS] Respuesta exitosa desde: ${data.source || 'unknown'} source`);
                }

                if (!silent) {
                    console.log(`üì° Respuesta API: ${data.messages?.length || 0} mensajes recibidos para chat ${chatId}`);
                    console.log(`üìä [API DETAILS] Total: ${data.total || 0}, Source: ${data.source || 'unknown'}, Timestamp: ${data.timestamp}`);
                }

                if (data.success && data.messages) {
                    // Asegurar que tenemos todos los mensajes hist√≥ricos
                    const allMessages = Array.isArray(data.messages) ? data.messages : [];
                    
                    // Log adicional para debugging de historial
                    if (forceReload && allMessages.length > 0 && !silent) {
                        console.log(`üìö [HISTORIAL COMPLETO] Cargados ${allMessages.length} mensajes desde ${data.source}`);
                        console.log(`   üìÖ Rango temporal: ${new Date(allMessages[0]?.timestamp).toLocaleString()} ‚Üí ${new Date(allMessages[allMessages.length - 1]?.timestamp).toLocaleString()}`);
                        console.log(`   üìä Distribuci√≥n: ${allMessages.filter(m => m.fromMe).length} enviados, ${allMessages.filter(m => !m.fromMe).length} recibidos`);

                        // Mostrar algunos tipos de mensaje
                        const messageTypes = {};
                        allMessages.forEach(msg => {
                            messageTypes[msg.type || 'text'] = (messageTypes[msg.type || 'text'] || 0) + 1;
                        });
                        console.log(`   üîç Tipos de mensaje:`, messageTypes);
                    }
                    
                    // Crear hash m√°s robusto incluyendo todos los mensajes
                    const messagesHash = allMessages.map(msg => {
                        const id = msg.id || msg.messageId || msg.timestamp || Date.now();
                        const body = (msg.body || msg.content || '').substring(0, 100);
                        const fromMe = msg.fromMe || false;
                        const status = msg.status || 'unknown';
                        const timestamp = msg.timestamp || 0;
                        return `${id}-${fromMe}-${body}-${status}-${timestamp}`;
                    }).join('|');

                    if (!silent) {
                        console.log(`üîç Hash actual: ${messagesHash.substring(0, 50)}...`);
                        console.log(`üîç Hash anterior: ${lastMessagesHash ? lastMessagesHash.substring(0, 50) + '...' : 'VAC√çO'}`);
                    }

                    // Actualizar solo si hay cambios reales (en modo silencioso no forzar actualizaci√≥n innecesaria)
                    const hasRealChanges = messagesHash !== lastMessagesHash;
                    const shouldUpdate = hasRealChanges || forceReload;

                    // En modo silencioso, solo actualizar si hay cambios reales para preservar scroll
                    if (shouldUpdate && (!silent || hasRealChanges)) {
                        if (!silent) {
                            if (forceReload) {
                                console.log('üîÑ RECARGA FORZADA - Actualizando todos los mensajes');
                            } else {
                                console.log('üìù ¬°NUEVOS MENSAJES DETECTADOS! - Actualizando chat en tiempo real');
                            }
                        }

                        // Actualizar el panel de chats para mostrar el √∫ltimo mensaje (solo si no es silencioso)
                        if (!silent && !forceReload) {
                            setTimeout(() => loadChats(), 500);
                        }
                        
                        lastMessagesHash = messagesHash;
                        
                        // *** SOLUCION: Combinar mensajes del servidor con mensajes web pendientes ***
                        const combinedMessages = combineMessagesWithPending(allMessages, chatId);

                        // Para recarga forzada (al seleccionar chat), NO preservar scroll - ir al final
                        // Para actualizaciones peri√≥dicas, S√ç preservar scroll
                        const preserveScroll = !forceReload && combinedMessages.length > 0;
                        displayMessages(combinedMessages, preserveScroll, silent);

                        // Limpiar mensajes web que ya aparecen en el servidor
                        cleanupSyncedWebMessages(allMessages, chatId);
                        
                        // *** CACHE: Guardar mensajes en cach√© si es la primera carga completa ***
                        if (forceReload && allMessages.length > 0 && !loadedChatsCache.has(chatId)) {
                            // Limitar cach√© a m√°ximo 100 mensajes (los m√°s recientes) para mejor experiencia m√≥vil
                            const limitedMessages = allMessages.length > 100 ? allMessages.slice(-100) : allMessages;
                            chatMessagesCache.set(chatId, [...limitedMessages]); // Copia profunda
                            loadedChatsCache.add(chatId);
                            console.log(`üíæ Chat ${chatId} agregado al cach√© con ${limitedMessages.length} mensajes (l√≠mite: 100)`);
                        } else if (forceReload && allMessages.length > 0 && loadedChatsCache.has(chatId)) {
                            // Actualizar cach√© existente con nuevos mensajes si los hay
                            const cachedMessages = chatMessagesCache.get(chatId) || [];
                            const newMessages = allMessages.filter(newMsg => 
                                !cachedMessages.some(cachedMsg => 
                                    cachedMsg.id === newMsg.id || 
                                    (Math.abs(cachedMsg.timestamp - newMsg.timestamp) < 1000 && 
                                     cachedMsg.body === newMsg.body && 
                                     cachedMsg.fromMe === newMsg.fromMe)
                                )
                            );
                            
                            if (newMessages.length > 0) {
                                const updatedMessages = [...cachedMessages, ...newMessages].sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
                                // Limitar a m√°ximo 100 mensajes (los m√°s recientes) para mejor experiencia m√≥vil
                                const limitedUpdatedMessages = updatedMessages.length > 100 ? updatedMessages.slice(-100) : updatedMessages;
                                chatMessagesCache.set(chatId, limitedUpdatedMessages);
                                console.log(`üíæ Cach√© actualizado para chat ${chatId}: +${newMessages.length} mensajes nuevos (l√≠mite: 100)`);
                            }
                        } else if (!forceReload && allMessages.length > 0 && loadedChatsCache.has(chatId)) {
                            // Actualizaci√≥n peri√≥dica: solo agregar mensajes nuevos al cach√©
                            const cachedMessages = chatMessagesCache.get(chatId) || [];
                            const newMessages = allMessages.filter(newMsg => 
                                !cachedMessages.some(cachedMsg => 
                                    cachedMsg.id === newMsg.id || 
                                    (Math.abs(cachedMsg.timestamp - newMsg.timestamp) < 1000 && 
                                     cachedMsg.body === newMsg.body && 
                                     cachedMsg.fromMe === newMsg.fromMe)
                                )
                            );
                            
                            if (newMessages.length > 0) {
                                const updatedMessages = [...cachedMessages, ...newMessages].sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
                                // Limitar a m√°ximo 100 mensajes (los m√°s recientes) para mejor experiencia m√≥vil
                                const limitedUpdatedMessages = updatedMessages.length > 100 ? updatedMessages.slice(-100) : updatedMessages;
                                chatMessagesCache.set(chatId, limitedUpdatedMessages);
                                console.log(`üíæ Cach√© actualizado (polling) para chat ${chatId}: +${newMessages.length} mensajes nuevos (l√≠mite: 100)`);
                            }
                        }
                        
                        // Si es recarga forzada, mostrar notificaci√≥n de historial cargado (solo una vez por chat)
                        if (forceReload && allMessages.length > 0 && !notificationShownChats.has(chatId)) {
                            notificationShownChats.add(chatId);
                            setTimeout(() => {
                                showHistoryLoadedNotification(allMessages.length);
                            }, 500);
                            console.log(`üîî Notificaci√≥n de mensajes cargados mostrada para chat ${chatId} (primera vez)`);
                        } else if (forceReload && allMessages.length > 0 && notificationShownChats.has(chatId)) {
                            console.log(`‚è∏Ô∏è Notificaci√≥n de mensajes cargados omitida para chat ${chatId} (ya se mostr√≥ antes)`);
                        }

                        // Actualizar contador de mensajes no le√≠dos si hay nuevos mensajes
                        const chat = chats.get(chatId);
                        if (chat && allMessages.length > 0) {
                            // Buscar mensajes no le√≠dos del remitente
                            const unreadMessages = allMessages.filter(msg => 
                                !msg.fromMe && 
                                (msg.isRead === false || !msg.hasOwnProperty('isRead'))
                            );
                            
                            if (unreadMessages.length > 0) {
                                console.log(`üîÑ ${unreadMessages.length} mensajes no le√≠dos detectados - actualizando contador`);
                                loadChats();
                            }
                        }

                        // Hacer scroll inteligente
                        setTimeout(() => {
                            const messagesArea = document.getElementById('messages-area');
                            if (messagesArea) {
                                if (forceReload || !preserveScroll) {
                                    // Scroll suave al final para carga inicial o recarga forzada
                                    messagesArea.scrollTo({
                                        top: messagesArea.scrollHeight,
                                        behavior: 'smooth'
                                    });
                                    console.log('üì± Scroll al final del historial completo');
                                }
                            }
                        }, 150);

                        // Log del historial cargado
                        if (allMessages.length > 0) {
                            const sortedMessages = [...allMessages].sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
                            const firstMsg = sortedMessages[0];
                            const lastMsg = sortedMessages[sortedMessages.length - 1];
                            
                            console.log(`‚úÖ Historial completo cargado para chat ${chatId}:`);
                            console.log(`   üìä Total: ${allMessages.length} mensajes`);
                            console.log(`   üìÖ Rango: ${formatTime(firstMsg.timestamp)} - ${formatTime(lastMsg.timestamp)}`);
                            console.log(`   üì§ Enviados: ${allMessages.filter(m => m.fromMe).length}`);
                            console.log(`   üì• Recibidos: ${allMessages.filter(m => !m.fromMe).length}`);
                        }

                    } else {
                        console.log('‚è∏Ô∏è Mensajes sin cambios - saltando actualizaci√≥n para preservar estado de audio/scroll');
                    }
                } else if (data.error) {
                    console.error('‚ùå Error en respuesta de API:', data.error);
                    
                    // Si hay error, intentar endpoint de fallback
                    try {
                        console.log('üîÑ Intentando endpoint de fallback...');
                        const fallbackResponse = await fetch(`/api/messages/${chatId}`);
                        if (fallbackResponse.ok) {
                            const fallbackData = await fallbackResponse.json();
                            if (fallbackData.messages) {
                                console.log(`üì° Endpoint fallback exitoso: ${fallbackData.messages.length} mensajes`);
                                displayMessages(fallbackData.messages, false, false); // No silencioso
                            }
                        }
                    } catch (fallbackError) {
                        console.error('‚ùå Tambi√©n fall√≥ el endpoint de fallback:', fallbackError);
                    }
                } else {
                    console.warn('‚ö†Ô∏è Respuesta API sin √©xito o sin mensajes:', data);
                }
            } catch (error) {
                console.error('‚ùå Error loading messages smart:', error);
                
                // Ocultar indicadores de carga si hay error
                if (loadingIndicator) {
                    hideHistoryLoadingIndicator();
                }
                hideLazyLoadingIndicator();
                
                // Estrategia de recuperaci√≥n progresiva
                const retryDelay = forceReload ? 5000 : 3000;
                setTimeout(() => {
                    if (currentChatId === chatId) {
                        console.log(`üîÑ Reintentando cargar mensajes despu√©s de error en ${retryDelay}ms...`);
                        loadMessagesSmart(chatId, false); // No forzar en reintentos
                    }
                }, retryDelay);
            } finally {
                // Asegurar que todos los indicadores de carga se oculten
                if (loadingIndicator) {
                    setTimeout(() => hideHistoryLoadingIndicator(), 1000);
                }
                // Tambi√©n ocultar el indicador lazy como seguridad
                setTimeout(() => hideLazyLoadingIndicator(), 1200);
            }
        }

        let lastConnectionState = null;
        let qrCheckInterval = null;
        let chatsInterval = null;
        let connectionCheckInterval = null;

        function startPolling() {
            // Chequeo de conexi√≥n cada 10 segundos
            if (!connectionCheckInterval) {
                connectionCheckInterval = setInterval(checkConnectionStatus, 10000);
            }

            // Chequeo inteligente de chats - solo cuando est√© conectado
            if (!chatsInterval) {
                chatsInterval = setInterval(() => {
                    console.log(`üîÑ [CHAT-INTERVAL] isConnected: ${isConnected}, ejecutando loadChats...`);
                    if (isConnected) {
                        loadChats();
                    } else {
                        console.log('‚ö†Ô∏è [CHAT-INTERVAL] WhatsApp no conectado, omitiendo loadChats');
                    }
                }, 2000); // Actualizaci√≥n cada 2 segundos para tiempo real
                console.log('‚úÖ Chat interval iniciado correctamente');
            }

            // Usar funci√≥n inteligente que solo actualiza cuando hay cambios
            startSmartMessagePolling();

            // Verificaci√≥n QR optimizada - solo cuando cambie el estado
            if (!qrCheckInterval) {
                qrCheckInterval = setInterval(() => {
                    // Solo procesar si el estado cambi√≥
                    if (lastConnectionState !== isConnected) {
                        lastConnectionState = isConnected;
                        
                        if (isConnected) {
                            const qrModal = document.getElementById('qr-modal');
                            if (qrModal && !qrModal.classList.contains('hidden')) {
                                const indicator = document.getElementById('qr-status-indicator');
                                const isClosingTransition = indicator && (
                                    indicator.innerHTML.includes('cerrar√° autom√°ticamente') ||
                                    indicator.innerHTML.includes('WhatsApp conectado')
                                );

                                if (!isClosingTransition) {
                                    hideQRModalManually();
                                }
                            }
                        } else {
                            // Solo actualizar botones QR cuando cambie a desconectado
                            updateQRButtonVisibility();
                            updateScanQRButtonVisibility();
                        }
                    }
                }, 15000); // Aumentado a 15 segundos
            }
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) return 'Ahora';
            if (diff < 3600000) return `${Math.floor(diff / 60000)}m`;
            if (diff < 86400000) return date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            return date.toLocaleDateString('es-ES');
        }

        function getMessageStatus(status) {
            switch (status) {
                case 'sending': return '?';
                case 'sent': return '?';
                case 'delivered': return '??';
                case 'read': return '??';
                default: return '';
            }
        }

        // Funci√≥n para formatear la preview de mensajes en la lista de chats
        function formatChatPreview(lastMessage) {
            if (!lastMessage) {
                return 'Sin mensajes';
            }

            // Detectar diferentes tipos de multimedia
            if (lastMessage.includes('<img')) {
                return 'üì∑ Imagen';
            }
            
            if (lastMessage.includes('<audio') || lastMessage.includes('üéµ') || lastMessage.includes('Audio del historial') || lastMessage.includes('audio-message-container')) {
                return 'üéµ Audio';
            }
            
            if (lastMessage.includes('<video') || lastMessage.includes('üé•')) {
                return 'üé• Video';
            }
            
            if (lastMessage.includes('üìÑ') || lastMessage.includes('document')) {
                return 'üìÑ Documento';
            }
            
            if (lastMessage.includes('üìé')) {
                return 'üìé Archivo adjunto';
            }

            // Si es texto normal, limitar longitud y limpiar HTML
            const cleanText = lastMessage
                .replace(/<[^>]*>/g, '') // Remover tags HTML
                .replace(/&nbsp;/g, ' ') // Convertir espacios no separables
                .replace(/&amp;/g, '&') // Convertir entidades HTML
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .trim();

            // Limitar longitud del texto
            if (cleanText.length > 50) {
                return cleanText.substring(0, 50) + '...';
            }

            return cleanText || 'Sin mensajes';
        }

        function formatMessageBody(body) {
            // Manejar elementos multimedia no disponibles PRIMERO
            if (body && (body.includes('video-unavailable') || body.includes('audio-unavailable') || body.includes('image-unavailable'))) {
                return body; // Retornar tal como est√°, ya est√° en formato correcto
            }
            
            if (body && (body.includes('<img') || body.includes('<audio') || body.includes('<video') || body.includes('<div class="audio-player"') || body.includes('<div class="video-player"') || body.includes('<div class="audio-message-container"'))) {
                if (body.includes('<img')) {
                    return body.replace(/<img([^>]*?)>/g, '<img$1 onclick="showImageModal(this.src)" style="cursor: pointer;" onerror="this.onerror=null; this.src=\'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDIwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjIwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmOGY5ZmEiIHN0cm9rZT0iI2RlZTJlNiIvPjx0ZXh0IHg9IjEwMCIgeT0iNTAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjNjY2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iMC4zZW0iPuKaoCBJbWFnZW4gbm8gZGlzcG9uaWJsZTwvdGV4dD48L3N2Zz4=\'; this.alt=\'Imagen no disponible\'; console.error(\'Error cargando imagen:\', this.dataset.originalSrc || this.src);">');
                }

                // Manejar espec√≠ficamente contenedores de mensajes de audio
                if (body.includes('<div class="audio-message-container"')) {
                    return body; // Retornar tal como est√°, ya est√° en formato correcto
                }

                // Mejorar elementos de audio para evitar interrupciones y agregar soporte multi-formato
                if (body.includes('<audio')) {
                    return body.replace(/<audio([^>]*?)>([\s\S]*?)<\/audio>/g, (match, attrs, content) => {
                        // Agregar controles si no los tiene
                        let newAttrs = attrs;
                        if (!attrs.includes('controls')) {
                            newAttrs += ' controls';
                        }

                        // Configurar preload para mejor buffering
                        if (!attrs.includes('preload=')) {
                            newAttrs += ' preload="metadata"';
                        }

                        // Agregar atributos para mejor control de preservaci√≥n y buffering
                        if (!attrs.includes('data-audio-preserve')) {
                            newAttrs += ' data-audio-preserve="true"';
                        }

                        // Configurar buffering optimizado para evitar entrecortamiento
                        if (!attrs.includes('playsinline')) {
                            newAttrs += ' playsinline';
                        }

                        // Agregar manejo de errores
                        if (!attrs.includes('onerror')) {
                            newAttrs += ' onerror="this.style.display=\'none\'; this.nextElementSibling.style.display=\'block\';"';
                        }

                        // Crear elemento audio con soporte multi-formato
                        const audioHtml = `<audio${newAttrs}>${content}</audio>`;

                        // Agregar un mensaje de error personalizado
                        const errorMessage = `
                            <div class="audio-error-message" style="
                                color: #666;
                                font-size: 12px;
                                margin-top: 8px;
                                padding: 8px;
                                background: #f8f9fa;
                                border-radius: 4px;
                                border: 1px solid #dee2e6;
                                display: none;
                            ">
                                <strong>‚ö†Ô∏è Tu navegador no soporta el elemento de audio.</strong><br>
                                <span style="font-size: 11px;">Formato: audio/ogg - Intenta usar un navegador actualizado como Chrome, Firefox o Edge.</span>
                            </div>
                        `;

                        return `
                            <div class="audio-container">
                                ${audioHtml}
                                ${errorMessage}
                            </div>
                        `;
                    });
                }

                // Mejorar elementos de video
                if (body.includes('<video')) {
                    return body.replace(/<video([^>]*?)>([\s\S]*?)<\/video>/g, (match, attrs, content) => {
                        // Agregar controles si no los tiene
                        let newAttrs = attrs;
                        if (!attrs.includes('controls')) {
                            newAttrs += ' controls';
                        }
                        
                        // Configurar preload para mejor buffering
                        if (!attrs.includes('preload=')) {
                            newAttrs += ' preload="metadata"';
                        }
                        
                        // Agregar playsinline para m√≥viles
                        if (!attrs.includes('playsinline')) {
                            newAttrs += ' playsinline';
                        }
                        
                        // Agregar manejo de errores
                        if (!attrs.includes('onerror')) {
                            newAttrs += ' onerror="this.style.display=\'none\'; this.nextElementSibling.style.display=\'block\';"';
                        }
                        
                        const videoHtml = `<video${newAttrs}>${content}</video>`;
                        
                        const errorMessage = `
                            <div class="video-error-message" style="
                                color: #666;
                                font-size: 12px;
                                margin-top: 8px;
                                padding: 8px;
                                background: #f8f9fa;
                                border-radius: 4px;
                                border: 1px solid #dee2e6;
                                display: none;
                            ">
                                <strong>‚ö†Ô∏è No se pudo cargar el video.</strong><br>
                                <small>Verifica tu conexi√≥n o intenta recargar la p√°gina.</small>
                            </div>
                        `;
                        
                        return `
                            <div class="video-container">
                                ${videoHtml}
                                ${errorMessage}
                            </div>
                        `;
                    });
                }

                return body;
            }
            
            // Si el body contiene HTML escapado, intentar "des-escaparlo"
            if (body && (body.includes('&lt;div') || body.includes('&lt;img') || body.includes('&lt;audio') || body.includes('&lt;video'))) {
                console.log('üêõ DEBUG - HTML escapado detectado, des-escapando...');
                console.log('üêõ DEBUG - Body original:', body.substring(0, 200) + '...');
                
                const unescapedBody = body
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&quot;/g, '"')
                    .replace(/&#x27;/g, "'")
                    .replace(/&#39;/g, "'")
                    .replace(/&amp;/g, '&');
                    
                console.log('üêõ DEBUG - HTML des-escapado:', unescapedBody.substring(0, 200) + '...');
                
                // Intentar procesar el HTML des-escapado
                if (unescapedBody.includes('<div class="video-unavailable"') || unescapedBody.includes('<div class="audio-unavailable"') || unescapedBody.includes('<div class="image-unavailable"')) {
                    console.log('üêõ DEBUG - Retornando HTML des-escapado');
                    return unescapedBody;
                }
            }
            
            return escapeHtml(body || '');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Funci√≥n para corregir URLs multimedia al protocolo correcto
        function fixMultimediaUrls() {
            const currentProtocol = window.location.protocol;
            const currentHost = window.location.host;
            
            console.log(`üîß Corrigiendo URLs multimedia a ${currentProtocol}//${currentHost}`);
            
            // Corregir URLs de im√°genes
            document.querySelectorAll('img[src^="/"]').forEach(img => {
                if (!img.src.startsWith(currentProtocol)) {
                    const relativePath = img.getAttribute('src');
                    const newUrl = `${currentProtocol}//${currentHost}${relativePath}`;
                    console.log(`üñºÔ∏è Corrigiendo imagen: ${img.src} -> ${newUrl}`);
                    img.src = newUrl;
                }
            });
            
            // Corregir URLs de audios
            document.querySelectorAll('audio source[src^="/"], audio[src^="/"]').forEach(source => {
                const srcAttr = source.getAttribute('src');
                if (srcAttr && srcAttr.startsWith('/')) {
                    const newUrl = `${currentProtocol}//${currentHost}${srcAttr}`;
                    console.log(`üéµ Corrigiendo audio: ${srcAttr} -> ${newUrl}`);
                    source.src = newUrl;
                    // Recargar el audio parent si existe
                    if (source.parentElement && source.parentElement.tagName === 'AUDIO') {
                        source.parentElement.load();
                    }
                }
            });
            
            // Corregir URLs de videos
            document.querySelectorAll('video source[src^="/"], video[src^="/"]').forEach(source => {
                const srcAttr = source.getAttribute('src');
                if (srcAttr && srcAttr.startsWith('/')) {
                    const newUrl = `${currentProtocol}//${currentHost}${srcAttr}`;
                    console.log(`üé• Corrigiendo video: ${srcAttr} -> ${newUrl}`);
                    source.src = newUrl;
                    // Recargar el video parent si existe
                    if (source.parentElement && source.parentElement.tagName === 'VIDEO') {
                        source.parentElement.load();
                    }
                }
            });
        }

        // Funci√≥n para manejar errores de elementos de audio y mejorar buffering
        function setupAudioErrorHandling() {
            // Usar delegaci√≥n de eventos para manejar elementos de audio din√°micos
            document.addEventListener('error', function(e) {
                if (e.target && e.target.tagName === 'AUDIO') {
                    handleAudioError(e.target);
                }
            }, true);

            // Tambi√©n manejar el evento 'abort' y 'error' espec√≠ficamente para audio
            document.addEventListener('DOMNodeInserted', function(e) {
                if (e.target && e.target.querySelectorAll) {
                    const audioElements = e.target.querySelectorAll('audio');
                    audioElements.forEach(audio => {
                        if (!audio.hasAttribute('data-error-handled')) {
                            audio.setAttribute('data-error-handled', 'true');

                            // Manejar errores
                            audio.addEventListener('error', function() {
                                handleAudioError(audio);
                            });

                            // Mejorar buffering agregando eventos de carga
                            audio.addEventListener('loadstart', function() {
                                console.log('üéµ Audio: Iniciando carga...');
                            });

                            audio.addEventListener('canplay', function() {
                                console.log('üéµ Audio: Listo para reproducir');
                            });

                            audio.addEventListener('waiting', function() {
                                console.log('üéµ Audio: Esperando datos...');
                                // Intentar reanudar autom√°ticamente si est√° pausado por buffering
                                if (audio.paused && audio.readyState < 4) {
                                    audio.play().catch(err => console.log('No se pudo reanudar:', err));
                                }
                            });

                            audio.addEventListener('playing', function() {
                                console.log('üéµ Audio: Reproduciendo correctamente');
                            });

                            // Optimizar buffering para conexiones lentas
                            audio.addEventListener('timeupdate', function() {
                                // Si hay menos de 5 segundos de buffer, intentar cargar m√°s datos
                                if (audio.buffered.length > 0) {
                                    const bufferedEnd = audio.buffered.end(audio.buffered.length - 1);
                                    const currentTime = audio.currentTime;
                                    if (bufferedEnd - currentTime < 5 && !audio.paused) {
                                        // Forzar carga de m√°s datos si es necesario
                                        audio.preload = 'auto';
                                    }
                                }
                            });
                        }
                    });
                }
            });
        }

        // Funci√≥n adicional para optimizar buffering de audio
        function optimizeAudioBuffering() {
            console.log('üîß Optimizando configuraci√≥n de buffering de audio...');

            // Configurar propiedades de audio para mejor rendimiento
            const audioElements = document.querySelectorAll('audio');
            audioElements.forEach(audio => {
                // Configurar tama√±o de buffer para evitar entrecortamiento
                if (audio.readyState > 0) {
                    // Establecer propiedades para mejor reproducci√≥n
                    audio.autoplay = false; // Evitar reproducci√≥n autom√°tica problem√°tica
                    audio.volume = audio.volume || 1.0; // Asegurar volumen adecuado

                    // Optimizar para conexiones lentas
                    if ('mozPreserveDrawingBuffer' in audio) {
                        audio.mozPreserveDrawingBuffer = true;
                    }
                }
            });

            console.log('‚úÖ Optimizaci√≥n de buffering completada');
        }

        // Funci√≥n para forzar actualizaci√≥n de mensajes (√∫til para debugging)
        function forceMessageUpdate() {
            console.log('üîÑ Forzando actualizaci√≥n de mensajes...');
            lastMessagesHash = ''; // Reset hash to force update
            if (currentChatId) {
                loadMessagesSmart(currentChatId);
            }
        }

        // Funci√≥n de diagn√≥stico para verificar el estado del tiempo real
        function diagnoseRealtime() {
            console.log('üîç === DIAGN√ìSTICO TIEMPO REAL ===');
            console.log(`   Chat actual: ${currentChatId || 'Ninguno'}`);
            console.log(`   √öltimo hash de mensajes: ${lastMessagesHash ? lastMessagesHash.substring(0, 50) + '...' : 'Vac√≠o'}`);
            console.log(`   Polling activo: ${messagePollingInterval ? 'S√≠' : 'No'}`);
            console.log(`   Chats cargados: ${chats.size}`);

            if (currentChatId) {
                console.log('   üì° Probando conexi√≥n a API...');
                loadMessagesSmart(currentChatId).then(() => {
                    console.log('   ‚úÖ API responde correctamente');
                }).catch(error => {
                    console.error('   ‚ùå Error en API:', error);
                });
            }

            console.log('   üí° Sugerencias:');
            console.log('      - Si no se actualizan los mensajes, usa forceMessageUpdate()');
            console.log('      - Usa testAPIEndpoints() para verificar ambos endpoints');
            console.log('      - Revisa la consola del navegador para errores detallados');
            console.log('      - El sistema verifica cada 3 segundos autom√°ticamente');
        }

        // Funci√≥n para probar ambos endpoints de API
        async function testAPIEndpoints() {
            if (!currentChatId) {
                console.error('‚ùå No hay chat seleccionado');
                return;
            }

            console.log('üß™ === PRUEBA DE ENDPOINTS API ===');

            // Probar endpoint correcto
            try {
                console.log('üì° Probando /api/chats/${chatId}/messages...');
                const response1 = await fetch(`/api/chats/${currentChatId}/messages`);
                if (response1.ok) {
                    const data1 = await response1.json();
                    console.log('‚úÖ /api/chats/${chatId}/messages funciona:', data1.messages?.length || 0, 'mensajes');
                } else {
                    console.error('‚ùå /api/chats/${chatId}/messages fall√≥:', response1.status);
                }
            } catch (error) {
                console.error('‚ùå Error en /api/chats/${chatId}/messages:', error);
            }

            // Probar endpoint alternativo
            try {
                console.log('üì° Probando /api/chats/.../messages...');
                const response2 = await fetch(`/api/chats/${currentChatId}/messages`);
                if (response2.ok) {
                    const data2 = await response2.json();
                    console.log('‚úÖ /api/chats/.../messages funciona:', data2.messages?.length || 0, 'mensajes');
                } else {
                    console.error('‚ùå /api/chats/.../messages fall√≥:', response2.status);
                }
            } catch (error) {
                console.error('‚ùå Error en /api/chats/.../messages:', error);
            }
        }

        // Funci√≥n para monitoreo en tiempo real (√∫til para debugging)
        let realtimeMonitor = null;
        function startRealtimeMonitor() {
            if (realtimeMonitor) {
                clearInterval(realtimeMonitor);
            }

            console.log('üî¨ Iniciando monitor en tiempo real...');
            realtimeMonitor = setInterval(() => {
                if (currentChatId) {
                    console.log(`üîç [MONITOR] Chat: ${currentChatId} | Hash: ${lastMessagesHash ? 'ACTIVO' : 'VAC√çO'} | Polling: ${messagePollingInterval ? 'ON' : 'OFF'}`);
                } else {
                    console.log('üîç [MONITOR] Sin chat seleccionado');
                }
            }, 5000); // Log cada 5 segundos
        }

        function stopRealtimeMonitor() {
            if (realtimeMonitor) {
                clearInterval(realtimeMonitor);
                realtimeMonitor = null;
                console.log('‚èπÔ∏è Monitor en tiempo real detenido');
            }
        }

        // Funci√≥n de diagn√≥stico para problemas de sesi√≥n
        function diagnoseSession() {
            console.log('üîç === DIAGN√ìSTICO DE SESI√ìN ===');
            console.log(`   token: ${token ? 'PRESENTE' : 'FALTANTE'}`);
            console.log(`   localStorage token: ${localStorage.getItem('token') ? 'PRESENTE' : 'FALTANTE'}`);
            console.log(`   currentUser: ${currentUser ? currentUser.username : 'NULO'}`);
            console.log(`   Estado de red: ${navigator.onLine ? 'ONLINE' : 'OFFLINE'}`);

            if (token) {
                console.log('   üîç Probando validaci√≥n de sesi√≥n...');
                validateSession().then(isValid => {
                    console.log(`   ‚úÖ Validaci√≥n: ${isValid ? 'V√ÅLIDA' : 'INV√ÅLIDA'}`);
                }).catch(error => {
                    console.error('   ‚ùå Error en validaci√≥n:', error);
                });
            } else {
                console.error('   ‚ùå NO HAY SESSIONID - Problema de autenticaci√≥n');
                console.log('   üí° Sugerencias:');
                console.log('      - Verifica que hayas iniciado sesi√≥n');
                console.log('      - Revisa la consola del navegador para errores de login');
                console.log('      - Intenta refrescar la p√°gina');
            }

            console.log('   üí° Si persiste el problema:');
            console.log('      - Usa clearSession() para limpiar datos corruptos');
            console.log('      - Revisa que la API /api/session est√© funcionando');
        }

        // Funci√≥n para desmarcar todos los chats como pendientes
        async function clearAllChats() {
            // Mostrar confirmaci√≥n al usuario
            const confirmed = confirm(
                'üîÑ ¬øDeseas desmarcar TODOS los chats pendientes?\n\n' +
                'Esta acci√≥n:\n' +
                '‚Ä¢ Ocultar√° todos los chats de la lista actual\n' +
                '‚Ä¢ Los chats seguir√°n existiendo pero no aparecer√°n como pendientes\n' +
                '‚Ä¢ Solo se mostrar√°n nuevos mensajes entrantes\n\n' +
                '¬øContinuar?'
            );

            if (!confirmed) {
                console.log('üö´ Desmarcado de chats cancelado por el usuario');
                return;
            }

            try {
                console.log('üîÑ Desmarcando todos los chats como pendientes...');
                showNotification('Desmarcando todos los chats pendientes...', 'info');

                const response = await fetch('/api/unmark-all-pending', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();

                if (result.success) {
                    console.log(`‚úÖ ${result.details.unmarked} chats desmarcados como pendientes exitosamente`);
                    showNotification(`‚úÖ ${result.details.unmarked} chats desmarcados como pendientes`, 'success');

                    // Limpiar la lista actual (se ocultar√°n todos los chats)
                    const chatsList = document.getElementById('chat-list');
                    if (chatsList) {
                        chatsList.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #8b949e;">
                                <i class="fas fa-check-circle" style="font-size: 2em; margin-bottom: 10px;"></i>
                                <p>Todos los chats han sido desmarcados como pendientes</p>
                                <small style="color: #666;">Solo aparecer√°n nuevos mensajes entrantes</small>
                            </div>
                        `;
                    }

                    // Limpiar √°rea de mensajes
                    const messagesArea = document.getElementById('messages-area');
                    if (messagesArea) {
                        messagesArea.innerHTML = '';
                    }

                    // Recargar la lista de chats (deber√≠a estar vac√≠a ahora)
                    setTimeout(() => {
                        loadChats();
                    }, 1000);

                } else {
                    console.error('‚ùå Error desmarcando chats:', result.message);
                    showNotification('‚ùå Error desmarcando chats: ' + result.message, 'error');
                }

            } catch (error) {
                console.error('‚ùå Error en la solicitud de desmarcado:', error);
                showNotification('‚ùå Error al desmarcar chats', 'error');
            }
        }

        // Funci√≥n para limpiar mensajes (eliminar parte inferior) - mantenida para compatibilidad
        function clearBottomMessages() {
            const messagesArea = document.getElementById('messages-area');
            if (messagesArea) {
                const messages = messagesArea.querySelectorAll('.message');
                if (messages.length > 10) {
                    // Mantener solo los primeros 10 mensajes, eliminar el resto
                    for (let i = 10; i < messages.length; i++) {
                        messages[i].remove();
                    }
                    console.log(`üßπ Se eliminaron ${messages.length - 10} mensajes de la parte inferior`);
                    showNotification(`Mensajes antiguos eliminados (mantenidos los √∫ltimos 10)`, 'info');
                }
            }
        }

        // Funci√≥n para limpiar datos de sesi√≥n corruptos
        function clearSession() {
            console.log('üßπ Limpiando datos de sesi√≥n...');
            localStorage.removeItem('token');
            token = null;
            currentUser = null;
            showNotification('Sesi√≥n limpiada. Redirigiendo al login...', 'info');
            setTimeout(() => showLoginScreen(), 1000);
        }

        // Llamar a la optimizaci√≥n cuando se cargue la p√°gina
        window.addEventListener('load', function() {
            setTimeout(optimizeAudioBuffering, 1000); // Esperar 1 segundo para que se carguen los elementos
        });

        function handleAudioError(audioElement) {
            const container = audioElement.closest('.audio-container');
            if (container) {
                const errorMessage = container.querySelector('.audio-error-message');
                if (errorMessage) {
                    errorMessage.style.display = 'block';

                    // Intentar detectar el tipo de error m√°s espec√≠ficamente
                    let errorType = 'desconocido';
                    if (audioElement.error) {
                        switch (audioElement.error.code) {
                            case MediaError.MEDIA_ERR_ABORTED:
                                errorType = 'abortado';
                                break;
                            case MediaError.MEDIA_ERR_NETWORK:
                                errorType = 'de red';
                                break;
                            case MediaError.MEDIA_ERR_DECODE:
                                errorType = 'de decodificaci√≥n';
                                break;
                            case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                                errorType = 'formato no soportado';
                                break;
                        }
                    }

                    // Obtener informaci√≥n del formato
                    let formatInfo = '';
                    if (audioElement.src) {
                        const url = new URL(audioElement.src);
                        const pathname = url.pathname;
                        const extension = pathname.substring(pathname.lastIndexOf('.') + 1).toLowerCase();
                        formatInfo = `Formato: audio/${extension}`;
                    }

                    // Actualizar el mensaje de error con informaci√≥n m√°s detallada
                    const errorText = errorMessage.querySelector('span');
                    if (errorText) {
                        errorText.innerHTML = `${formatInfo} - Error: ${errorType}.<br>Intenta usar un navegador actualizado como Chrome, Firefox o Edge.`;
                    }

                    console.log(`üéµ Audio error: ${errorType} - ${formatInfo}`);
                }
            }
        }

        function showImageModal(imageSrc) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.9); display: flex; justify-content: center; 
                align-items: center; z-index: 10000; cursor: pointer;
            `;
            
            const img = document.createElement('img');
            img.src = imageSrc;
            img.style.cssText = `
                max-width: 95%; max-height: 95%; border-radius: 12px; 
                object-fit: contain; cursor: pointer;
            `;
            
            const closeBtn = document.createElement('div');
            closeBtn.innerHTML = '?';
            closeBtn.style.cssText = `
                position: absolute; top: 20px; right: 30px; color: white; 
                font-size: 30px; cursor: pointer; background: rgba(0,0,0,0.5); 
                border-radius: 50%; width: 40px; height: 40px; display: flex; 
                justify-content: center; align-items: center;
            `;
            
            modal.appendChild(img);
            modal.appendChild(closeBtn);
            document.body.appendChild(modal);
            
            img.onclick = function(e) { e.stopPropagation(); };
            modal.onclick = closeBtn.onclick = function() {
                        document.body.removeChild(modal);
            };
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.getElementById('notifications').appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            
                setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // FUNCIONES PARA NÔøΩMEROS OMITIDOS
        // ===== FUNCIONES PARA DASHBOARD DE SALUD DEL BOT =====
        async function showHealthDashboard() {
            const modal = document.getElementById('health-dashboard-modal');
            if (modal) {
                modal.classList.remove('hidden');
                await loadHealthData();
                // Auto-refresh cada 5 segundos mientras est√° abierto
                if (window.healthRefreshInterval) clearInterval(window.healthRefreshInterval);
                window.healthRefreshInterval = setInterval(loadHealthData, 5000);
            }
        }

        function closeHealthDashboard() {
            const modal = document.getElementById('health-dashboard-modal');
            if (modal) {
                modal.classList.add('hidden');
                if (window.healthRefreshInterval) {
                    clearInterval(window.healthRefreshInterval);
                    window.healthRefreshInterval = null;
                }
            }
        }

        async function loadHealthData() {
            try {
                const response = await fetch('/api/bot-health');
                const data = await response.json();

                // Actualizar estado general
                const statusBadge = document.getElementById('health-status-badge');
                if (data.whatsappListo) {
                    statusBadge.textContent = '‚úì OPERATIVO';
                    statusBadge.style.background = 'rgba(76, 175, 80, 0.9)';
                } else {
                    statusBadge.textContent = '‚úó DESCONECTADO';
                    statusBadge.style.background = 'rgba(244, 67, 54, 0.9)';
                }

                document.getElementById('health-whatsapp-state').textContent = data.estado;
                document.getElementById('health-uptime').textContent = `${data.tiempoActivo.horas}h`;
                document.getElementById('health-active-chats').textContent = data.chatsActivos;

                // Actualizar mensajes
                document.getElementById('health-success-count').textContent = data.mensajes.exitosos;
                document.getElementById('health-success-rate').textContent = `${data.mensajes.tasaExito}% tasa de √©xito`;
                document.getElementById('health-error-count').textContent = data.mensajes.fallidos;
                document.getElementById('health-error-rate').textContent = `${data.mensajes.tasaError}% tasa de error`;

                // Actualizar l√≠mites diarios
                document.getElementById('health-daily-count').textContent =
                    `${data.limites.mensajesHoy} / ${data.limites.maxDiario}`;
                document.getElementById('health-daily-bar').style.width = `${data.limites.porcentajeDiario}%`;
                document.getElementById('health-daily-percentage').textContent = `${data.limites.porcentajeDiario}%`;

                // Cambiar color de barra seg√∫n porcentaje
                const dailyBar = document.getElementById('health-daily-bar');
                if (parseFloat(data.limites.porcentajeDiario) > 80) {
                    dailyBar.style.background = 'linear-gradient(90deg, #f56565, #c53030)';
                } else if (parseFloat(data.limites.porcentajeDiario) > 60) {
                    dailyBar.style.background = 'linear-gradient(90deg, #ed8936, #dd6b20)';
                } else {
                    dailyBar.style.background = 'linear-gradient(90deg, #4299e1, #3182ce)';
                }

                // Actualizar l√≠mites por hora
                document.getElementById('health-hourly-count').textContent =
                    `${data.limites.mensajesHora} / ${data.limites.maxHora}`;
                document.getElementById('health-hourly-bar').style.width = `${data.limites.porcentajeHora}%`;
                document.getElementById('health-hourly-percentage').textContent = `${data.limites.porcentajeHora}%`;

                const hourlyBar = document.getElementById('health-hourly-bar');
                if (parseFloat(data.limites.porcentajeHora) > 80) {
                    hourlyBar.style.background = 'linear-gradient(90deg, #f56565, #c53030)';
                } else if (parseFloat(data.limites.porcentajeHora) > 60) {
                    hourlyBar.style.background = 'linear-gradient(90deg, #ed8936, #dd6b20)';
                } else {
                    hourlyBar.style.background = 'linear-gradient(90deg, #48bb78, #38a169)';
                }

                // Actualizar alertas
                const alertsContainer = document.getElementById('health-alerts-container');
                const alertsList = document.getElementById('health-alerts-list');
                if (data.alertas && data.alertas.length > 0) {
                    alertsContainer.style.display = 'block';
                    alertsList.innerHTML = data.alertas.map(alerta =>
                        `<div style="margin: 5px 0;">‚Ä¢ ${alerta}</div>`
                    ).join('');

                    // Mostrar punto de alerta en el bot√≥n
                    updateHealthButtonAlert(true);
                } else {
                    alertsContainer.style.display = 'none';
                    updateHealthButtonAlert(false);
                }

                // Actualizar √∫ltimo error
                const lastErrorContainer = document.getElementById('health-last-error-container');
                const lastErrorDetails = document.getElementById('health-last-error-details');
                if (data.ultimoError) {
                    lastErrorContainer.style.display = 'block';
                    lastErrorDetails.innerHTML = `
                        <strong>Chat:</strong> ${data.ultimoError.chatId}<br>
                        <strong>Mensaje:</strong> ${data.ultimoError.mensaje}<br>
                        <strong>Fecha:</strong> ${new Date(data.ultimoError.timestamp).toLocaleString('es')}
                    `;
                } else {
                    lastErrorContainer.style.display = 'none';
                }

                // Actualizar mensajes del chatbot
                const chatbotMessagesContainer = document.getElementById('health-chatbot-messages');
                if (data.mensajesChatbot && data.mensajesChatbot.length > 0) {
                    chatbotMessagesContainer.innerHTML = data.mensajesChatbot.map(msg => {
                        const fecha = new Date(msg.timestamp).toLocaleString('es', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        const isEntrante = msg.tipo === 'entrante';
                        const bgColor = isEntrante ? '#e3f2fd' : '#f1f8e9';
                        const icon = isEntrante ? 'fa-arrow-down' : 'fa-arrow-up';
                        const iconColor = isEntrante ? '#2196f3' : '#4caf50';
                        const label = isEntrante ? 'Entrante' : 'Saliente';

                        return `
                            <div style="background: ${bgColor}; border-left: 4px solid ${iconColor}; padding: 12px; margin-bottom: 10px; border-radius: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <i class="fas ${icon}" style="color: ${iconColor};"></i>
                                        <strong style="color: #2d3748; font-size: 0.9em;">${label}</strong>
                                        <span style="color: #4a5568; font-size: 0.85em;">${msg.nombre || msg.chatId.substring(0, 15)}</span>
                                    </div>
                                    <span style="color: #718096; font-size: 0.8em;">${fecha}</span>
                                </div>
                                <div style="color: #4a5568; font-size: 0.9em; margin-left: 28px;">${msg.mensaje}</div>
                            </div>
                        `;
                    }).join('');
                } else {
                    chatbotMessagesContainer.innerHTML = `
                        <div style="text-align: center; color: #718096; padding: 40px;">
                            <i class="fas fa-inbox" style="font-size: 3em; opacity: 0.3; margin-bottom: 10px;"></i>
                            <div>No hay mensajes recientes</div>
                        </div>
                    `;
                }

            } catch (error) {
                console.error('Error cargando datos de salud:', error);
            }
        }

        function updateHealthButtonAlert(hasAlert) {
            const healthBtn = document.querySelector('.btn-health');
            if (!healthBtn) return;

            let alertDot = healthBtn.querySelector('.alert-dot');
            if (hasAlert) {
                if (!alertDot) {
                    alertDot = document.createElement('span');
                    alertDot.className = 'alert-dot';
                    healthBtn.appendChild(alertDot);
                }
            } else {
                if (alertDot) {
                    alertDot.remove();
                }
            }
        }

        async function refreshHealthDashboard() {
            const btn = event.target.closest('button');
            const icon = btn.querySelector('i');

            // Animaci√≥n del √≠cono
            icon.style.animation = 'spin 1s linear';
            await loadHealthData();
            setTimeout(() => {
                icon.style.animation = '';
            }, 1000);
        }

        // Agregar animaci√≥n de spin
        const style = document.createElement('style');
        style.textContent = `
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
        `;
        document.head.appendChild(style);

        async function showOmittedModal() {
            const modal = document.getElementById('omitted-modal');
            if (modal) {
                modal.classList.remove('hidden');
                await loadOmittedNumbers();
            }
        }

        function closeOmittedModal() {
            const modal = document.getElementById('omitted-modal');
            if (modal) {
                modal.classList.add('hidden');
                document.getElementById('omitted-number').value = '';
                document.getElementById('omitted-reason').value = '';

                // Limpiar b√∫squeda
                const searchInput = document.getElementById('omitted-search');
                const clearButton = document.getElementById('omitted-clear-search');
                if (searchInput) searchInput.value = '';
                if (clearButton) clearButton.style.display = 'none';
            }
        }

        async function loadOmittedNumbers() {
            try {
                const response = await fetch(`/api/omitted-numbers?token=${token}`);
                const data = await response.json();

                if (data.success) {
                    displayOmittedNumbers(data.numeros);
                } else {
                    showNotification('Error cargando nÔøΩmeros omitidos', 'error');
                }
            } catch (error) {
                console.error('Error cargando nÔøΩmeros omitidos:', error);
                showNotification('Error de conexiÔøΩn', 'error');
            }
        }

        // Variable global para almacenar todos los n√∫meros omitidos
        let allOmittedNumbers = [];

        function displayOmittedNumbers(numeros) {
            // Guardar todos los n√∫meros para el filtrado
            allOmittedNumbers = numeros || [];

            const omittedList = document.getElementById('omitted-list');
            if (!omittedList) return;

            if (!numeros || numeros.length === 0) {
                omittedList.innerHTML = `
                    <div class="omitted-no-results">
                        <i class="fas fa-inbox"></i>
                        <p>No hay n√∫meros omitidos registrados</p>
                    </div>
                `;
                updateOmittedSearchStats(0, 0);
                return;
            }

            renderOmittedNumbers(numeros);
            updateOmittedSearchStats(numeros.length, allOmittedNumbers.length);
        }

        function renderOmittedNumbers(numeros) {
            const omittedList = document.getElementById('omitted-list');
            if (!omittedList) return;

            if (numeros.length === 0) {
                omittedList.innerHTML = `
                    <div class="omitted-no-results">
                        <i class="fas fa-search"></i>
                        <p>No se encontraron n√∫meros que coincidan con la b√∫squeda</p>
                        <small style="margin-top: 10px; display: block;">Intenta con otros t√©rminos de b√∫squeda</small>
                    </div>
                `;
                return;
            }

            omittedList.innerHTML = numeros.map(numero => `
                <div class="omitted-item" data-id="${numero.id}">
                    <button class="delete-btn" onclick="eliminarNumeroOmitido(${numero.id})" title="Eliminar n√∫mero">
                        <i class="fas fa-trash"></i>
                    </button>
                    <div class="numero">${numero.numero}</div>
                    <div class="motivo">${numero.motivo || 'Sin motivo especificado'}</div>
                    <div class="meta">
                        <span>Agregado por: ${numero.creado_por}</span>
                        <span>${formatDate(numero.fecha_creacion)}</span>
                    </div>
                </div>
            `).join('');
        }

        function filterOmittedNumbers() {
            const searchInput = document.getElementById('omitted-search');
            const clearButton = document.getElementById('omitted-clear-search');

            if (!searchInput) return;

            const searchTerm = searchInput.value.toLowerCase().trim();

            // Mostrar/ocultar bot√≥n de limpiar
            if (searchTerm.length > 0) {
                clearButton.style.display = 'flex';
            } else {
                clearButton.style.display = 'none';
            }

            // Filtrar n√∫meros
            let filteredNumbers = allOmittedNumbers;

            if (searchTerm.length > 0) {
                filteredNumbers = allOmittedNumbers.filter(numero => {
                    const numeroStr = numero.numero.toLowerCase();
                    const motivoStr = (numero.motivo || '').toLowerCase();
                    const creadoPorStr = numero.creado_por.toLowerCase();

                    return numeroStr.includes(searchTerm) ||
                           motivoStr.includes(searchTerm) ||
                           creadoPorStr.includes(searchTerm);
                });
            }

            renderOmittedNumbers(filteredNumbers);
            updateOmittedSearchStats(filteredNumbers.length, allOmittedNumbers.length);
        }

        function clearOmittedSearch() {
            const searchInput = document.getElementById('omitted-search');
            const clearButton = document.getElementById('omitted-clear-search');

            if (searchInput) {
                searchInput.value = '';
                searchInput.focus();
            }

            if (clearButton) {
                clearButton.style.display = 'none';
            }

            // Mostrar todos los n√∫meros
            renderOmittedNumbers(allOmittedNumbers);
            updateOmittedSearchStats(allOmittedNumbers.length, allOmittedNumbers.length);
        }

        function updateOmittedSearchStats(showing, total) {
            const statsElement = document.getElementById('omitted-search-stats');
            if (!statsElement) return;

            if (total === 0) {
                statsElement.textContent = '';
                return;
            }

            if (showing === total) {
                statsElement.textContent = `Mostrando ${total} n√∫mero${total !== 1 ? 's' : ''}`;
            } else {
                statsElement.textContent = `Mostrando ${showing} de ${total} n√∫mero${total !== 1 ? 's' : ''}`;
            }
        }

        function handleOmittedSearchKeydown(event) {
            // Escape para limpiar b√∫squeda
            if (event.key === 'Escape') {
                clearOmittedSearch();
                event.preventDefault();
            }
        }

        // Funci√≥n para detectar y corregir problemas de scroll en m√≥viles
        function fixMobileScrollIssues() {
            const messagesArea = document.getElementById('messages-area');
            if (!messagesArea) return;
            
            const isMobile = window.innerWidth <= 768;
            if (!isMobile) return;
            
            // Verificar si hay problemas de scroll
            const totalHeight = messagesArea.scrollHeight;
            const visibleHeight = messagesArea.clientHeight;
            const currentScroll = messagesArea.scrollTop;
            const maxScroll = totalHeight - visibleHeight;
            
            // Si hay contenido que no es visible y no estamos al final
            if (maxScroll > 0 && currentScroll < maxScroll - 100) {
                console.log('üîß Detectado problema de scroll en m√≥vil, corrigiendo...');
                
                // Intentar m√∫ltiples m√©todos de scroll
                messagesArea.scrollTop = totalHeight;
                
                setTimeout(() => {
                    messagesArea.scrollTo(0, totalHeight);
                }, 50);
                
                setTimeout(() => {
                    messagesArea.scrollIntoView({ block: 'end', behavior: 'smooth' });
                }, 100);
            }
        }
        
        // Detectar cuando se agregan nuevos elementos al chat
        let scrollObserver;
        function initMobileScrollObserver() {
            const messagesArea = document.getElementById('messages-area');
            if (!messagesArea || scrollObserver) return;
            
            const isMobile = window.innerWidth <= 768;
            if (!isMobile) return;
            
            scrollObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        // Se agregaron nuevos mensajes, verificar scroll
                        setTimeout(fixMobileScrollIssues, 200);
                    }
                });
            });
            
            scrollObserver.observe(messagesArea, {
                childList: true,
                subtree: true
            });
            
            console.log('üëÅÔ∏è Observer de scroll m√≥vil iniciado');
        }

        async function agregarNumeroOmitido() {
            const numero = document.getElementById('omitted-number').value.trim();
            const motivo = document.getElementById('omitted-reason').value.trim();

            if (!numero) {
                showNotification('Por favor ingresa un nÔøΩmero', 'error');
                return;
            }

            if (!/^\d+$/.test(numero)) {
                showNotification('El nÔøΩmero solo debe contener dÔøΩgitos', 'error');
                return;
            }

            try {
                const response = await fetch('/api/omitted-numbers', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ numero, motivo, token })
                });

                const data = await response.json();

                if (data.success) {
                    showNotification(data.message, 'success');
                    document.getElementById('omitted-number').value = '';
                    document.getElementById('omitted-reason').value = '';
                    await loadOmittedNumbers();
                } else {
                    showNotification(data.message, 'error');
                }
            } catch (error) {
                console.error('Error agregando nÔøΩmero omitido:', error);
                showNotification('Error de conexiÔøΩn', 'error');
            }
        }

        async function eliminarNumeroOmitido(id) {
            if (!confirm('ÔøΩEstÔøΩs seguro de que quieres eliminar este nÔøΩmero omitido?')) return;

            try {
                const response = await fetch(`/api/omitted-numbers/${id}?token=${token}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    showNotification(data.message, 'success');
                    await loadOmittedNumbers();
                } else {
                    showNotification(data.message, 'error');
                }
            } catch (error) {
                console.error('Error eliminando nÔøΩmero omitido:', error);
                showNotification('Error de conexiÔøΩn', 'error');
            }
        }

        // FUNCIONES PARA ADMINISTRACIÔøΩN DE USUARIOS
        async function showUsersAdminModal() {
            const modal = document.getElementById('users-admin-modal');
            if (modal) {
                modal.classList.remove('hidden');
                await loadUsersAdmin();
            }
        }

        function closeUsersAdminModal() {
            const modal = document.getElementById('users-admin-modal');
            if (modal) modal.classList.add('hidden');
        }

        async function loadUsersAdmin() {
            try {
                // Validar sesi√≥n antes de la operaci√≥n
                const sessionValid = await validateSession();
                if (!sessionValid) return;

                if (!currentUser || currentUser.rol !== 'admin') {
                    showNotification('Acceso denegado: Solo administradores pueden ver esta informaciÔøΩn', 'error');
                    return;
                }

                const response = await fetch(`/api/users?token=${token}`);
                
                if (!response.ok) {
                    if (response.status === 403) {
                        showNotification('Acceso denegado', 'error');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data.success) {
                    displayUsersAdmin(data.users || []);
                } else {
                    showNotification(data.message || 'Error cargando usuarios', 'error');
                }
            } catch (error) {
                console.error('Error cargando usuarios:', error);
                showNotification(`Error de conexiÔøΩn: ${error.message}`, 'error');
            }
        }

        function displayUsersAdmin(users) {
            const usersList = document.getElementById('users-admin-list');
            if (!usersList) return;

            if (!users || users.length === 0) {
                usersList.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No hay usuarios registrados</p>';
                return;
            }

            usersList.innerHTML = users.map(user => `
                <div class="omitted-item">
                    <div class="user-actions" style="position: absolute; top: 10px; right: 10px; display: flex; gap: 8px;">
                        <button class="edit-btn" onclick="editarUsuario(${user.id}, '${user.username}', '${user.nombre}', '${user.rol}')" ${(user.username === 'admin' || user.username === 'api_user' || user.username === 'api') ? 'style="display:none;"' : ''} title="Editar usuario">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="delete-btn" onclick="eliminarUsuarioAdmin(${user.id})" ${(user.username === 'admin' || user.username === 'api_user' || user.username === 'api') ? 'style="display:none;"' : ''} title="Eliminar usuario">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                    <div class="numero">?? ${user.username}</div>
                    <div class="motivo">${user.nombre} - Rol: ${user.rol === 'admin' ? 'Administrador' : user.rol === 'api' ? 'API Especial' : 'Soporte'}</div>
                    <div class="meta">Creado: ${formatDate(user.fecha_creacion)}</div>
                </div>
            `).join('');
        }

        async function eliminarUsuarioAdmin(id) {
            if (!confirm('ÔøΩEstÔøΩs seguro de que quieres eliminar este usuario?')) return;

            try {
                const response = await fetch(`/api/users/${id}?token=${token}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    showNotification(data.message, 'success');
                    await loadUsersAdmin();
                } else {
                    showNotification(data.message, 'error');
                }
            } catch (error) {
                console.error('Error eliminando usuario:', error);
                showNotification('Error de conexiÔøΩn', 'error');
            }
        }

        function editarUsuario(id, username, nombre, rol) {
            document.getElementById('edit-user-id').value = id;
            document.getElementById('edit-user-username').value = username;
            document.getElementById('edit-user-nombre').value = nombre;
            document.getElementById('edit-user-role').value = rol;
            document.getElementById('edit-user-password').value = '';

            const modal = document.getElementById('edit-user-modal');
            if (modal) {
                modal.classList.remove('hidden');
            }
        }

        function closeEditUserModal() {
            const modal = document.getElementById('edit-user-modal');
            if (modal) {
                modal.classList.add('hidden');
                document.getElementById('edit-user-id').value = '';
                document.getElementById('edit-user-username').value = '';
                document.getElementById('edit-user-password').value = '';
                document.getElementById('edit-user-nombre').value = '';
                document.getElementById('edit-user-role').value = 'soporte';
            }
        }

        function showAddUserModal() {
            const modal = document.getElementById('add-user-modal');
            if (modal) {
                modal.classList.remove('hidden');
                document.getElementById('new-user-username').value = '';
                document.getElementById('new-user-password').value = '';
                document.getElementById('new-user-nombre').value = '';
                document.getElementById('new-user-role').value = 'soporte';
            }
        }

        function closeAddUserModal() {
            const modal = document.getElementById('add-user-modal');
            if (modal) {
                modal.classList.add('hidden');
                document.getElementById('new-user-username').value = '';
                document.getElementById('new-user-password').value = '';
                document.getElementById('new-user-nombre').value = '';
                document.getElementById('new-user-role').value = 'soporte';
            }
        }

        async function agregarUsuario() {
            const username = document.getElementById('new-user-username').value.trim();
            const password = document.getElementById('new-user-password').value.trim();
            const nombre = document.getElementById('new-user-nombre').value.trim();
            const rol = document.getElementById('new-user-role').value;

            if (!username || !password || !nombre) {
                showNotification('Por favor completa todos los campos obligatorios', 'error');
                return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(username)) {
                showNotification('El nombre de usuario solo puede contener letras, nÔøΩmeros y guiones bajos', 'error');
                return;
            }

            if (password.length < 6) {
                showNotification('La contraseÔøΩa debe tener al menos 6 caracteres', 'error');
                return;
            }

            try {
                const response = await fetch('/api/users', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password, nombre, rol, token })
                });

                if (!response.ok) {
                    if (response.status === 403) {
                        showNotification('Acceso denegado: Solo administradores pueden crear usuarios', 'error');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data.success) {
                    showNotification(data.message, 'success');
                    closeAddUserModal();
                    await loadUsersAdmin();
                } else {
                    showNotification(data.message || 'Error creando usuario', 'error');
                }
            } catch (error) {
                console.error('Error creando usuario:', error);
                showNotification('Error de conexiÔøΩn al servidor', 'error');
            }
        }

        async function actualizarUsuario() {
            const id = document.getElementById('edit-user-id').value;
            const username = document.getElementById('edit-user-username').value.trim();
            const password = document.getElementById('edit-user-password').value.trim();
            const nombre = document.getElementById('edit-user-nombre').value.trim();
            const rol = document.getElementById('edit-user-role').value;

            if (!username || !nombre) {
                showNotification('Por favor completa los campos obligatorios', 'error');
                return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(username)) {
                showNotification('El nombre de usuario solo puede contener letras, nÔøΩmeros y guiones bajos', 'error');
                return;
            }

            if (password && password.length < 6) {
                showNotification('La contraseÔøΩa debe tener al menos 6 caracteres', 'error');
                return;
            }

            try {
                const updateData = { username, nombre, rol, token };
                if (password) updateData.password = password;

                const response = await fetch(`/api/users/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updateData)
                });

                if (!response.ok) {
                    if (response.status === 403) {
                        showNotification('Acceso denegado: Solo administradores pueden editar usuarios', 'error');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data.success) {
                    showNotification(data.message, 'success');
                    closeEditUserModal();
                    await loadUsersAdmin();
                } else {
                    showNotification(data.message || 'Error actualizando usuario', 'error');
                }
            } catch (error) {
                console.error('Error actualizando usuario:', error);
                showNotification('Error de conexiÔøΩn al servidor', 'error');
            }
        }

        // FUNCIONES PARA LOGS DE API
        async function showLogsAPIModal() {
            const modal = document.getElementById('logs-api-modal');
            if (modal) {
                modal.classList.remove('hidden');
                await loadLogsAPI();
            }
        }

        function closeLogsAPIModal() {
            const modal = document.getElementById('logs-api-modal');
            if (modal) modal.classList.add('hidden');
        }

        async function loadLogsAPI() {
            try {
                // Validar sesi√≥n antes de la operaci√≥n
                const sessionValid = await validateSession();
                if (!sessionValid) return;

                const response = await fetch(`/api/logs-api?token=${token}&limit=100`);
                
                if (!response.ok) {
                    if (response.status === 403) {
                        showNotification('Acceso denegado', 'error');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data.success) {
                    displayLogsAPI(data.logs || []);
                } else {
                    showNotification(data.message || 'Error cargando logs', 'error');
                }
            } catch (error) {
                console.error('Error cargando logs API:', error);
                showNotification('Error de conexiÔøΩn al servidor', 'error');
            }
        }

        function displayLogsAPI(logs) {
            const logsList = document.getElementById('logs-api-list');
            if (!logsList) return;

            if (!logs || logs.length === 0) {
                logsList.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No hay logs registrados</p>';
                return;
            }

            logsList.innerHTML = logs.map(log => {
                const estadoIcon = getEstadoIcon(log.estado);
                const estadoColor = getEstadoColor(log.estado);
                
                return `
                <div class="omitted-item">
                    <div class="numero">
                        ${estadoIcon} ${log.numero_destino}
                        <span style="background: ${estadoColor}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">
                            ${getEstadoText(log.estado)}
                        </span>
                    </div>
                    <div class="motivo">
                        <strong>IP:</strong> ${log.ip_origen} ÔøΩ 
                        <strong>Mensaje:</strong> ${log.mensaje.length > 100 ? log.mensaje.substring(0, 100) + '...' : log.mensaje}
                    </div>
                    <div class="meta">
                        ${formatDate(log.fecha_envio)}
                    </div>
                </div>
            `;
            }).join('');
        }

        function getEstadoIcon(estado) {
            switch(estado) {
                case 'enviado': return '?';
                case 'error_envio': return '?';
                case 'error_parametros': return '??';
                case 'error_whatsapp_no_listo': return '??';
                case 'error_excepcion': return '??';
                default: return '??';
            }
        }

        function getEstadoColor(estado) {
            switch(estado) {
                case 'enviado': return '#28a745';
                case 'error_envio': return '#dc3545';
                case 'error_parametros': return '#ffc107';
                case 'error_whatsapp_no_listo': return '#17a2b8';
                case 'error_excepcion': return '#6f42c1';
                default: return '#6c757d';
            }
        }

        function getEstadoText(estado) {
            switch(estado) {
                case 'enviado': return 'Enviado';
                case 'error_envio': return 'Error EnvÔøΩo';
                case 'error_parametros': return 'Error ParÔøΩmetros';
                case 'error_whatsapp_no_listo': return 'WhatsApp No Listo';
                case 'error_excepcion': return 'Error ExcepciÔøΩn';
                default: return estado;
            }
        }

        // FUNCIONES PARA NUEVO CHAT
        function showNewChatModal() {
            const modal = document.getElementById('new-chat-modal');
            if (modal) {
                modal.classList.remove('hidden');
                const phoneInput = document.getElementById('new-chat-phone');
                const messageInput = document.getElementById('new-chat-message');
                
                phoneInput.value = '';
                messageInput.value = '';
                
                // Agregar validaci√≥n en tiempo real para solo n√∫meros
                phoneInput.oninput = function() {
                    this.value = this.value.replace(/[^0-9]/g, '');
                    if (this.value.length > 10) {
                        this.value = this.value.slice(0, 10);
                    }
                };
                
                // Agregar enter para enviar
                messageInput.onkeypress = function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        createNewChat();
                    }
                };
                
                setTimeout(() => phoneInput.focus(), 300);
            }
        }

        function closeNewChatModal() {
            const modal = document.getElementById('new-chat-modal');
            if (modal) {
                modal.classList.add('hidden');
                document.getElementById('new-chat-phone').value = '';
                document.getElementById('new-chat-message').value = '';
            }
        }

        async function createNewChat(event) {
            if (event) {
                event.preventDefault();
            }
            
            const numero = document.getElementById('new-chat-phone').value.trim();
            let mensaje = document.getElementById('new-chat-message').value.trim();
            
            if (!numero) {
                showNotification('Por favor ingresa un nÔøΩmero de telÔøΩfono', 'error');
                return;
            }

            if (!/^[0-9]{10}$/.test(numero)) {
                showNotification('El nÔøΩmero debe contener solo dÔøΩgitos (10-15 caracteres)', 'error');
                return;
            }

            // Validar que empiece con 3 (n√∫meros m√≥viles en Colombia)
            if (!numero.startsWith('3')) {
                showNotification('El n√∫mero m√≥vil debe comenzar con 3', 'error');
                return;
            }

            if (!mensaje) {
                mensaje = 'Buenos dÔøΩas, Bienvenido a SOLUCNET';
            }

            // Validar que tengamos un token v√°lido
            if (!token) {
                showNotification('‚ùå No hay token de autorizaci√≥n. Por favor, inicia sesi√≥n nuevamente.', 'error');
                return;
            }

            try {
                console.log('üîÑ Creando nuevo chat:', {
                    numeroIngresado: numero,
                    chatId: '57' + numero + '@c.us',
                    mensaje: mensaje,
                    token: token ? 'PRESENTE' : 'AUSENTE'
                });

                // Verificar estado de WhatsApp antes de enviar
                console.log('üîç Verificando estado de WhatsApp...');
                try {
                    const statusResponse = await fetch('/api/stats', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        console.log('üìä Estado WhatsApp:', statusData);
                        
                        if (!statusData.whatsappListo) {
                            showNotification('‚ö†Ô∏è WhatsApp no est√° conectado. Por favor, escanea el c√≥digo QR primero.', 'warning');
                            return;
                        }
                    }
                } catch (statusError) {
                    console.warn('No se pudo verificar estado de WhatsApp:', statusError);
                    // Continuar de todas formas
                }

                // Crear AbortController para timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    console.warn('‚è∞ Petici√≥n cancelada por timeout (30 segundos)');
                }, 30000);

                const response = await fetch('/api/send-message', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        chatId: '57' + numero + '@c.us',
                        message: mensaje
                    }),
                    signal: controller.signal
                });
                
                // Limpiar timeout si la petici√≥n se complet√≥
                clearTimeout(timeoutId);

                let data;
                try {
                    data = await response.json();
                    console.log('üì° Respuesta del servidor:', data);
                } catch (parseError) {
                    console.error('Error parsing JSON response:', parseError);
                    throw new Error(`HTTP ${response.status} - Error parsing server response`);
                }

                if (response.ok && data.success) {
                    showNotification(`‚úÖ Mensaje enviado exitosamente a +57${numero}`, 'success');
                    closeNewChatModal();
                    loadUsersAdmin();
                    setTimeout(() => selectChat(`57${numero}@c.us`), 1000);
                } else {
                    let errorMsg = 'Error enviando mensaje';
                    
                    if (response.status === 500) {
                        errorMsg = 'Error interno del servidor. Verifica que WhatsApp est√© conectado.';
                        console.error('HTTP 500 - Server Error:', data);
                    } else if (response.status === 401) {
                        errorMsg = 'Token de autorizaci√≥n inv√°lido. Reinicia sesi√≥n.';
                    } else if (response.status === 404) {
                        errorMsg = 'Endpoint no encontrado. Verifica la configuraci√≥n del servidor.';
                    } else {
                        errorMsg = data.message || data.error || `Error HTTP ${response.status}`;
                    }
                    
                    showNotification(`‚ùå ${errorMsg}`, 'error');
                    console.error('Error detallado:', {
                        status: response.status,
                        statusText: response.statusText,
                        data: data,
                        chatId: '57' + numero + '@c.us'
                    });
                }
            } catch (error) {
                console.error('Error creando nuevo chat:', error);
                
                let errorMessage = 'Error de conexi√≥n al servidor';
                
                if (error.name === 'AbortError') {
                    errorMessage = '‚è∞ La petici√≥n fue cancelada por timeout (30s). El servidor tard√≥ demasiado en responder.';
                } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    errorMessage = 'üîå Error de red - servidor no responde. Verifica tu conexi√≥n.';
                } else if (error.message.includes('interrupted')) {
                    errorMessage = '‚ö†Ô∏è Petici√≥n interrumpida - intenta de nuevo';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'üîå No se pudo conectar al servidor. Verifica que est√© funcionando.';
                } else if (error.message) {
                    errorMessage = `‚ùå Error: ${error.message}`;
                }
                
                console.error('Detalles del error:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                
                showNotification(errorMessage, 'error');
            }
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('es-ES', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Funci√≥n para recuperar mensajes tras reconexi√≥n de WhatsApp
        async function recoverMessagesAfterReconnection() {
            try {
                console.log('üîÑ [RECOVERY] Iniciando recuperaci√≥n de mensajes tras reconexi√≥n...');
                
                const response = await fetch('/api/recovery/messages');
                const data = await response.json();
                
                if (data.success && data.recoveredChats && data.recoveredChats.length > 0) {
                    console.log(`üîÑ [RECOVERY] ${data.totalChats} chats con mensajes recuperados`);
                    
                    // Actualizar lista de chats para mostrar los chats con mensajes recuperados
                    loadChats();
                    
                    // Si hay un chat actualmente seleccionado, refrescar sus mensajes
                    if (currentChatId) {
                        const chatRecuperado = data.recoveredChats.find(chat => chat.chatId === currentChatId);
                        if (chatRecuperado) {
                            console.log(`üîÑ [RECOVERY] Refrescando chat activo: ${currentChatId}`);
                            loadMessagesSmart(currentChatId, true); // Forzar recarga completa
                        }
                    }
                    
                    // Mostrar notificaci√≥n de recuperaci√≥n exitosa
                    const totalMessages = data.recoveredChats.reduce((sum, chat) => sum + chat.totalRecovered, 0);
                    showNotification(`üîÑ Recuperados ${totalMessages} mensajes de ${data.totalChats} conversaciones activas`, 'success');
                    
                } else {
                    console.log('üîÑ [RECOVERY] No hay mensajes para recuperar');
                }
                
            } catch (error) {
                console.error('‚ùå [RECOVERY] Error recuperando mensajes:', error);
                showNotification('‚ö†Ô∏è Error al recuperar mensajes tras reconexi√≥n', 'warning');
            }
        }

        // Agregar headers de autenticaciÔøΩn a las peticiones
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
            if (token && args[0].startsWith('/api/')) {
                if (!args[1]) args[1] = {};
                if (!args[1].headers) args[1].headers = {};
                args[1].headers['Authorization'] = `Bearer ${token}`;
            }
            return originalFetch.apply(this, args);
        };
    </script>
</body>
